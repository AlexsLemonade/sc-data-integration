---
params:
  group_name: "sim1"
  merged_sce_dir: "../results/scib_simulated/merged_sce"
  integrated_sce_dir: "../results/scib_simulated/integrated_sce"
  integration_methods: !r as.vector(c("fastmnn", "harmony", "cca", "rpca"))
  batch_column: "batch"
  celltype_column: "celltype"
  num_pcs: 20
  ari_k_min: 5
  ari_k_max: 25
  ari_k_increment: 5
  k0_fraction_min: 0.05
  k0_fraction_max: 0.25
  k0_fraction_increment: 0.05
  seed: 2022
  asw_separate_cell_types: FALSE
  date: !r Sys.Date()

title: "`r glue::glue('Integration evaluation for {params$group_name}')`"
author: "CCDL"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

## Set Up

```{r}
# load the R project
project_root <- here::here()
renv::load(project_root)
```


```{r}
suppressPackageStartupMessages({
 library(SingleCellExperiment)
 library(ggplot2)
})
theme_set(theme_bw())

set.seed(params$seed)
```


```{r setup}
utils_dir <- file.path(project_root, "scripts", "utils")

# source the helper functions to grab the integration method check
source(file.path(utils_dir, "integration-helpers.R"))

# source plotting functions
source(file.path(utils_dir, "plotting-functions.R"))

# source functions for calculating integration metrics
source(file.path(utils_dir, "calculate-ARI.R"))
source(file.path(utils_dir, "calculate-silhouette-width.R"))
source(file.path(utils_dir, "calculate-LISI.R"))
source(file.path(utils_dir, "run-metrics.R"))

# Set up hook for printing warnings
knitr::knit_hooks$set(
   warning = function(x, options) {
     paste('\n\n<div class="alert alert-warning">',
           gsub('##', '\n', gsub('^##\ Warning:', '**Warning**', x)),
           '</div>', sep = '\n')
   }
)

# Ensure logical
asw_separate_cell_types <- as.logical(toupper(params$asw_separate_cell_types))
if (!(asw_separate_cell_types) %in% c(TRUE, FALSE)) {
  stop("\nCould not read the asw_separate_cell_types` parameter.")
}
```


```{r}
# build file paths for merged and integrated files
merged_sce_file <- paste0(params$group_name, "_merged_sce.rds")
merged_sce_path <- file.path(params$merged_sce_dir,
                             merged_sce_file)

# check for merged/ unintegrated SCE file
if(!file.exists(merged_sce_path)){
  stop("Merged SCE file provided does not exist")
}
```


```{r}
# find all integrated SCE files for given project
integrated_sce_files <- list.files(params$integrated_sce_dir,
                                   # search for groupname followed by underscore so you remove any matches that have similar group names
                                   pattern = paste0(params$group_name, "_"),
                                   full.names = TRUE)

# extract integration methods for project from list of possible methods based on files that exist
expected_methods <- params$integration_methods %>%
  # if reading param from snakefile list need to split into a comma separated vector 
  stringr::str_split(pattern = " ") %>%
  unlist() %>%
  # if seurat methods are included remove seurat prefix 
  stringr::str_remove("seurat-")

expected_methods_check <- paste(expected_methods, collapse = "|")

# subset integrated sce files so that they only contain the expected methods and no extraneous files from other methods
integrated_sce_files <- integrated_sce_files[grep(expected_methods_check, integrated_sce_files)]
integration_methods <- stringr::str_extract(integrated_sce_files, expected_methods_check)

# check to make sure all integration methods are accounted for and have an associated file
if( !identical(sort(integration_methods), sort(expected_methods))){
  stop("All integration files are not present in provided `integrated_sce_dir`.")
}

# construct a list of all sce files for reading in merged + integrated files together
all_sce_files <- c(merged_sce_path, integrated_sce_files)

# read in rds files and create a list of all sce objects
sce_list <- purrr::map(all_sce_files, readr::read_rds) %>%
  set_names(c("unintegrated", integration_methods))
```



```{r sce-checks}

# check that batch column is found in colData of both merged and integrated sce objects
# first find all the column names of the coldata found in common
coldata_names <- sce_list %>%
    purrr::map(~ colnames(colData(.))) %>%
    unname() %>%
    unlist() %>%
    unique()

if(!params$batch_column %in% coldata_names){
  stop("Provided batch_column should be present in both the colData of the merged SCE and all integrated SCE objects.")
}


# check that umaps for pre-integrated and integrated are present
check_umap_name <- function(sce,
                            integration_method){

  if(integration_method == "unintegrated"){
    umap_name <- "UMAP"
  } else {
    # grab dim reduction name to use for plotting
    umap_name <- paste0(integration_method, "_UMAP")
  }

  if(!umap_name %in% reducedDimNames(sce)){
    missing_umap <- umap_name
  } else {
    missing_umap <- NULL
  }

  return(missing_umap)
}

missing_umap <- purrr::imap(sce_list, check_umap_name) %>%
  unlist()
if(!is.null(missing_umap)){
  stop(glue::glue("
       Missing UMAP embeddings from SCE object. Make sure that UMAP embeddings are present and labeled with {missing_umap}.
      "))
}

# Check whether celltype information is available
if(params$celltype_column %in% coldata_names){
  # Set variable to TRUE
  celltypes_present <- TRUE
  
  # Calculate percentage of cells for which this information is known
  #  and print informative message
  celltypes <- colData(sce_list$unintegrated)[[params$celltype_column]]
  percent_present <- round( sum(!(is.na(celltypes))) / length(celltypes), 3) * 100

  if (percent_present < 100) {
    warning(
      glue::glue("
        Only {percent_present}% of cells in these libraries have cell type annotations. 
        Cells without annotations are not considered in calculations or visualizations that assess cell type mixing.
      ")
    )
  }
} else {
  celltypes_present <- FALSE
  warning("No cell type information found for this dataset. Cannot make UMAPs annotated with cell type or evaluate cell type mixing.")
}
  
```


## UMAPs

```{r batch-umaps, fig.height=15, fig.width=10, warning=FALSE, message=FALSE}
# create umap plots labeling by batch column
batch_umaps <- names(sce_list) %>%
  purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                      integration_method = .x,
                                     params$group_name,
                                     cell_label_column = params$batch_column,
                                     seed = params$seed))
  batch_legend <- cowplot::get_legend(batch_umaps[[1]])
  
  ggpubr::ggarrange(plotlist = batch_umaps,
                    common.legend = TRUE, 
                    legend = "right",
                    legend.grob = batch_legend, 
                    ncol = 2, 
                    nrow = 4) 
```




```{r celltype-umaps, fig.width=15, fig.height=20, warning=FALSE, message=FALSE}
# only print out celltype UMAP plot if celltype information is provided
if(celltypes_present){
 # create umap plots labeling by celltype column
  celltype_umaps <- names(sce_list) %>%
    purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                       integration_method = .x,
                                       params$group_name,
                                       cell_label_column = params$celltype_column,
                                       seed = params$seed))
  
  celltype_legend <- cowplot::get_legend(celltype_umaps[[1]])
  
  ggpubr::ggarrange(plotlist = celltype_umaps,
                    common.legend = TRUE, 
                    legend = "right",
                    legend.grob = celltype_legend, 
                    ncol = 2, 
                    nrow = 4) 
} else {
  warning("No cell types are present, so no cell type-annotated UMAPs will be shown.")
}
```

## Integration metrics


### iLISI

The iLISI (integration local inverse Simpson's index) metric can be used to measure the local distribution of batches in the integrated dataset, as defined in [Korsunksky et al.](https://doi.org/10.1038/s41592-019-0619-0). 
The iLISI score can be interpreted as describing how many batches are represented within a local neighborhood. 
The range of iLISI scores will be from 1 to the number of batches, however we have normalized the score following the same method utilized by the `scIB` benchmarking tools: (ilisi - 1)/(num batches -1)
Therefore, we would expect that well integrated datasets to be close to 1 indicating high mixing of batches, while poorly integrated datasets would be close to 0 indicating poor mixing.


```{r fig.height=5, fig.width=5}

ilisi_results <- run_lisi(sce_list, params$batch_column, "iLISI")

# Plot results:
print(ilisi_results$lisi_plot)
```



### cLISI

Complementary to iLISI, the cLISI (_cell type_ local inverse Simpson's index) metric can be used to measure the local distribution of cell types in the integrated dataset, as defined in [Korsunksky et al.](https://doi.org/10.1038/s41592-019-0619-0). 
The cLISI score can be interpreted as describing how many cell types are represented within a local neighborhood. 
The range of cLISI scores will be from 1 to the number of cell types, however we have normalized the score following the same method utilized by the `scIB` benchmarking tools: (num cell types - clisi/(num cell types - 1)
Therefore, we would expect that well integrated datasets to be close to 0 indicating low mixing of cell types, while poorly integrated datasets would be close to 1 indicating high mixing of cell types.


```{r, fig.height=5, fig.width=5}
if (celltypes_present) {

  clisi_results <- run_lisi(sce_list, params$celltype, "cLISI")

  # Plot results:
  print(clisi_results$lisi_plot)
} else {
  warning("No cell types are present, so cLISI scores will not be evaluated.")
}
```
  
### Batch ARI

The below plots look at the batch adjusted rand index (ARI) for each integration method.
Cells are first downsampled to 80% of the total number of cells before clustering is performed using k-means clustering.
The ARI between clustering results and batch assignments is then calculated and this is repeated 20 times.
We also calculated batch ARI across a range of k for k-means, the number of centers used for clustering.
The plots show the batch ARI on the y-axis across each integration method and value of k used for k-means clustering.
The first plot shows the integration method on the x-axis and plots are faceted by values of k, while the second plot shows each integration method as a separate plot and displays batch ARI across the range of k indicated on the x-axis.
If datasets are well integrated we would expect the batch ARI to be close to 0 and the 1-batch ARI to be close to 1, indicating that batches are well integrated across clustering assignments with low concordance between clusters and batch assignment.

```{r}
# create k range needed for input to ARI function from params

# make sure that max is not less than min
if(params$ari_k_max < params$ari_k_min){
  stop("`ari_k_max` must be greater than `ari_k_min`.")
}

## get krange
k_range <- seq(params$ari_k_min,
               params$ari_k_max,
               params$ari_k_increment)
```

```{r, warning=FALSE}
# Calculate and visualize batch ARI
batch_ari <- run_ari(sce_list, params$batch_column, k_range, params$seed)
```

```{r}
# Visualize results, faceted across k
plot(batch_ari$ari_plot_k)

# Visualize results, faceted across integration_method
plot(batch_ari$ari_plot_integration_method)
```


### Cell type ARI

The below plots look at the cell type adjusted rand index (ARI) for each integration method.
The procedure for this calculation matches that of batch ARI, except cell type labels are used as group assignments rather than batch assignments.
The plots show the cell type ARI on the y-axis across each integration method and value of k used for k-means clustering.
The first plot shows the integration method on the x-axis and plots are faceted by values of k, while the second plot shows each integration method as a separate plot and displays cell type ARI across the range of k indicated on the x-axis.
If datasets are well integrated we would expect the cell type ARI to be close to 1 and the 1-batch ARI to be close to 0, indicating that cell types are well partitioned among clustering assignments with high concordance between clusters and cell type.


```{r, warning=FALSE}
if (celltypes_present) {
  # Calculate cell type ARI, using previously-defined k_range
  celltype_ari <- run_ari(sce_list, params$celltype_column, k_range, params$seed)
  
  # Visualize results, faceted across k
  plot(celltype_ari$ari_plot_k)
  
  # Visualize results, faceted across integration_method
  plot(celltype_ari$ari_plot_integration_method)
} else {
  warning("No cell types are present, so cell type ARI will not be evaluated.")
}
```


### Batch ASW

Below we look at the batch average silhouette width (ASW) across integration methods.
Silhouette width is used to assess consistency within clusters and measures how well a given data point adheres to its own cluster vs. other clusters.
To calculate this quantity, cells are first downsampled to 80% of the total number of cells.
Batch silhouette width is calculated across 20 replicates of downsampling, and the mean silhouette widths are calculated (ASW) and shown below.
The batch silhouette width therefore measures to what extent a given data point adheres to its batch group, which is not desired after integration.
Therefore, a well-integrated dataset would show lower batch ASW values compared to an unintegrated or poorly-integrated dataset, because batches should not primarily determine clustering after successful integration.


```{r fig.height=5, fig.width=7}
asw_results <- run_asw(sce_list, params$batch_column, params$seed) # defaults are fine: group by batch and label as `Batch`

# Plot results:
print(asw_results$asw_plot)
```


### Cell type ASW

Below we look at the cell type average silhouette width (ASW) across integration methods.
Calculations follow the same procedure as for batch ASW, except they evaluate the silhouette width across cell types rather than across batches.
A well-integrated dataset would show higher cell type ASW values compared to an unintegrated or poorly-integrated dataset, because cell types _should_ primarily determine clustering after successful integration.

Results below (if present) are shown first for all cell types together, and then shown separated by cell type.


```{r, fig.height=5, fig.width=7}
if (celltypes_present) {
  # Not separated
  asw_results <- run_asw(sce_list, params$celltype_column, params$seed, by_batch = FALSE)
  print(asw_results$asw_plot)
  
  # Separated, if specified in params
  if (asw_separate_cell_types) {
    asw_results <- run_asw(sce_list, params$celltype_column, params$seed, by_batch = TRUE, batch_label = "Cell type")
    print(asw_results$asw_plot)
  }
} else {
  warning("No cell types are present, so cell type ASW will not be evaluated.")
}
```


## Session Info

```{r session_info}
sessionInfo()
```
