---
params:
  group_name: "sim1"
  merged_sce_dir: "../results/scib_simulated/merged_sce"
  integrated_sce_dir: "../results/scib_simulated/integrated_sce"
  integration_methods: !r as.vector(c("fastmnn", "harmony", "cca", "rpca"))
  library_metadata: "../sample-info/scib-simulated-processed-libraries.tsv"
  batch_column: "batch"
  celltype_column: "celltype"
  max_celltypes: 5
  num_pcs: 20
  ari_k_min: 5
  ari_k_max: 25
  ari_k_increment: 5
  seed: 2022
  date: !r Sys.Date()

title: "`r glue::glue('Integration evaluation for {params$group_name}')`"
author: "CCDL"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
---

## Set Up

```{r}
# load the R project
project_root <- here::here()
renv::load(project_root)
```


```{r}
suppressPackageStartupMessages({
 library(SingleCellExperiment)
 library(ggplot2)
})
theme_set(theme_bw())

set.seed(params$seed)

# Maximum value for `max_celltypes` 
celltypes_ceiling <- 10
```


```{r setup}
utils_dir <- file.path(project_root, "scripts", "utils")

# source the helper functions to grab the integration method check
source(file.path(utils_dir, "integration-helpers.R"))

# source plotting functions
source(file.path(utils_dir, "plotting-functions.R"))

# source functions for calculating integration metrics
source(file.path(utils_dir, "calculate-ARI.R"))
source(file.path(utils_dir, "calculate-silhouette-width.R"))
source(file.path(utils_dir, "calculate-LISI.R"))
source(file.path(utils_dir, "run-metrics.R"))

# Set up hook for printing warnings
knitr::knit_hooks$set(
   warning = function(x, options) {
     paste('\n\n<div class="alert alert-warning">',
           gsub('##', '\n', gsub('^##\ Warning:', '**Warning**', x)),
           '</div>', sep = '\n')
   }, 
   message = function(x, options) {
     paste('\n\n<div class="alert alert-info">',
           gsub('##', '\n', x),
           '</div>', sep = '\n')
   }
)

# Check max_celltypes param
if (params$max_celltypes > celltypes_ceiling) {
  warning(
    glue::glue(
      "The requested number of celltypes {params$max_celltypes} is too high. 
      It will be changed to the maximum-allowed value of {celltypes_ceiling}"
    )
  )
  max_celltypes <- celltypes_ceiling
} else {
  max_celltypes <- params$max_celltypes
}
```


```{r}
# build file paths for merged and integrated files
merged_sce_file <- paste0(params$group_name, "_merged_sce.rds")
merged_sce_path <- file.path(params$merged_sce_dir,
                             merged_sce_file)

# check for merged/ unintegrated SCE file
if(!file.exists(merged_sce_path)){
  stop("Merged SCE file provided does not exist")
}
```


```{r}
# find all integrated SCE files for given project
integrated_sce_files <- list.files(params$integrated_sce_dir,
                                   # search for groupname followed by underscore so you remove any matches that have similar group names
                                   pattern = paste0(params$group_name, "_"),
                                   full.names = TRUE)

# extract integration methods for project from list of possible methods based on files that exist
expected_methods <- params$integration_methods %>%
  # if reading param from snakefile list need to split into a comma separated vector 
  stringr::str_split(pattern = " ") %>%
  unlist() %>%
  # if seurat methods are included remove seurat prefix 
  stringr::str_remove("seurat-")

expected_methods_check <- paste(expected_methods, collapse = "|")

# subset integrated sce files so that they only contain the expected methods and no extraneous files from other methods
integrated_sce_files <- integrated_sce_files[grep(expected_methods_check, integrated_sce_files)]
integration_methods <- stringr::str_extract(integrated_sce_files, expected_methods_check)

# check to make sure all integration methods are accounted for and have an associated file
if( !identical(sort(integration_methods), sort(expected_methods))){
  stop("All integration files are not present in provided `integrated_sce_dir`.")
}

# construct a list of all sce files for reading in merged + integrated files together
all_sce_files <- c(merged_sce_path, integrated_sce_files)

# read in rds files and create a list of all sce objects
sce_list <- purrr::map(all_sce_files, readr::read_rds) %>%
  set_names(c("unintegrated", integration_methods))
```

```{r}
# find all pre-integrated sce files for a project and create a list 
# to do that read in the library metadata
# filter to the group and grab the library ids and the integration input directory
if(!file.exists(params$library_metadata)){
  stop("Provided `library_metadata` file does not exist.")
}

library_metadata <- readr::read_tsv(params$library_metadata) |> 
  dplyr::filter(project_name == params$group_name)

# grab the directory used as input to the integration workflow
individual_sce_dir <- library_metadata |> 
  dplyr::pull(integration_input_dir) |>
  unique() 
individual_sce_dir <- file.path(project_root, individual_sce_dir)

# construct the search pattern of all libraries to look for
library_id_pattern <- library_metadata |> 
  dplyr::pull(library_biomaterial_id) |> 
  paste(collapse = "|")

# get the full file path for all expected libraries
individual_sce_files <- list.files(individual_sce_dir,
                                   pattern = library_id_pattern,
                                   full.names = TRUE,
                                   recursive = TRUE)

# grab the library ids from the file paths
library_ids <- stringr::str_remove(basename(individual_sce_files), "_sce.rds")

# make sure that all the libraries we expect to be there have a corresponding file
if(!all(library_ids %in% library_metadata$library_biomaterial_id)){
  stop("Iindividual SCE objects not present for all libraries in group.")
}

# create list of individual sce objects 
individual_sce_list <- individual_sce_files |> 
  purrr::set_names(library_ids) |> 
  purrr::map(readr::read_rds)
```


```{r sce-checks}
# check that batch column is found in colData of both merged and integrated sce objects
# first find all the column names of the coldata found in common
coldata_names <- sce_list %>%
    purrr::map(~ colnames(colData(.))) %>%
    unname() %>%
    unlist() %>%
    unique()

if(!params$batch_column %in% coldata_names){
  stop("Provided batch_column should be present in both the colData of the merged SCE and all integrated SCE objects.")
}


# check that umaps for pre-integrated and integrated are present
check_umap_name <- function(sce,
                            integration_method){

  if(integration_method == "unintegrated"){
    umap_name <- "UMAP"
  } else {
    # grab dim reduction name to use for plotting
    umap_name <- paste0(integration_method, "_UMAP")
  }

  if(!umap_name %in% reducedDimNames(sce)){
    missing_umap <- umap_name
  } else {
    missing_umap <- NULL
  }

  return(missing_umap)
}

missing_umap <- purrr::imap(sce_list, check_umap_name) %>%
  unlist()
if(!is.null(missing_umap)){
  stop(glue::glue("
       Missing UMAP embeddings from SCE object. Make sure that UMAP embeddings are present and labeled with {missing_umap}.
      "))
}

# set colors to use for batches 
batch_colors <- sce_list$unintegrated[[params$batch_column]] %>%
    unique() %>%
    length() %>%
    rainbow()

# Check whether celltype information is available, and prepare if so
if(params$celltype_column %in% coldata_names){
  # Set variable to TRUE
  celltypes_present <- TRUE
  
  # Calculate percentage of cells for which this information is known
  #  and print informative message
  celltypes <- colData(sce_list$unintegrated)[[params$celltype_column]]
  percent_present <- round( sum(!(is.na(celltypes))) / length(celltypes), 3) * 100

  if (percent_present < 100) {
    warning(
      glue::glue("
        Only {percent_present}% of cells in these libraries have cell type annotations. 
        Cells without annotations are not considered in calculations or visualizations that assess cell type mixing.
      ")
    )
  } 
  
  # Prepare new column `celltype_plot_names` in SCE to contain celltypes 
  #  as they should be shown in relevant plots
  sce_list <- purrr::map(sce_list, 
     ~setup_celltype_plot_names(
      .x, 
      celltype_column = params$celltype_column,
      max_celltypes = max_celltypes)
  )
  
  # Prepare colors for celltypes as a stand-alone variable, based on unintegrated SCE
  celltype_colors <- sce_list$unintegrated$celltype_plot_names %>%
    unique() %>%
    length() %>%
    rainbow()
  
  # Print a warning with information about cell type reduction, if reduced
  if (!(all(sce_list$unintegrated$celltype == sce_list$unintegrated$celltype_plot_names))) {
    warning(
      glue::glue(
        'There are more cell types in this data than can be displayed in plots.
        Only the top {max_celltypes} cell types are explicitly shown in applicable plots. All remaining cell types are collectively designated as "other".
        To change this value, use the `max_celltypes` RMarkdown parameter.
        '
      )
    )
  }
} else {
  celltypes_present <- FALSE
  warning("No cell type information found for this dataset. Cannot make UMAPs annotated with cell type or evaluate cell type mixing.")
}
  
```

## Explore dataset size

This section displays information about the overall dataset size, number of batches, and number of cell types (if present).

First, how many batches and celltypes (if present) are there? If there are celltypes present, what are they?

```{r table-batch-celltypes}
# pull out an SCE object for this section
# all SCEs in the list should be equivalent for these calculations and plots
sce_coldata <- colData(sce_list[[1]]) %>% tibble::as_tibble()

# helper function to count
count_groups <- function(colname) {
  # colname: the column of interest we should count
  colname_sym <- rlang::sym(colname)
  sce_coldata %>%
    dplyr::count(!!colname_sym, name = "count")
}

# How many batches?
n_batch_df <- count_groups(params$batch_column)
print(
  glue::glue("There are {nrow(n_batch_df)} total batches, with the following number of cells:")
)
gt::gt(n_batch_df)

# If there are celltypes, perform calculations
if (celltypes_present == TRUE) {
  
  # How many celltypes?
  n_celltypes_df <- count_groups(params$celltype_column)
  print(
    glue::glue("There are {sum(is.na(sce_coldata[,params$celltype_column]))} cells of unknown subtype.
               
               There are {nrow(n_celltypes_df)} cells with annotated cell types, each with the following number of cells:")
  )
  gt::gt(n_celltypes_df)
}
```

If celltypes are available, a barplot below will show how the celltypes are distributed across batches. 
The total height of each bar corresponds to the number of cells in the given batch.
If celltypes are not available, there will not be a barplot here.


```{r barplot-batch-celltypes}
# If there are celltypes, make barplot
if (celltypes_present == TRUE) {
  plot_barplot_batch_celltype(sce_coldata, 
                              params$batch_column, 
                              "celltype_plot_names", 
                              plot_colors = celltype_colors)
}
```




```{r setup-plot-labels}
# Before plotting, set up some labels to use in plots so we can have `N=` in 
#  the legends for batches and celltypes, when present

# helper function:
extract_labels <- function(count_df, colname) {
  colname_sym <- rlang::sym(colname)
  # count_df is a tibble of counts with two columns: `colname`, and `count`
  count_df %>%
    dplyr::mutate(label = paste0(
      !!colname_sym, " (N=", count, ")"
      )
    ) %>%
    dplyr::pull(label)
}

# Create batch label vector
batch_plot_labels <- extract_labels(n_batch_df, params$batch_column)

# Create celltype label vector
if (celltypes_present) {
  celltype_plot_labels <- extract_labels(
    count_groups("celltype_plot_names"),
    "celltype_plot_names"
  )
}
```


## Merging and integration order

```{r, results='asis'}
# grab merge order from merged sce object
merge_order <- metadata(sce_list[["unintegrated"]])$merge_order

message(glue::glue("The libraries in this dataset were merged in the following order: {merge_order}"))
```


```{r, results='asis'}
if("fastmnn" %in% integration_methods){
  # grab fastmnn auto merge from fastmnn object
  fastmnn_integration_order <- metadata(sce_list[["fastmnn"]])$fastmnn_auto_merge
  
  message(glue::glue("The libraries in this dataset were integrated in the following order when integrated with fastmnn: {fastmnn_integration_order}"))
  
}
```



## UMAPs

```{r batch-umaps, fig.height=15, fig.width=10, warning=FALSE, message=FALSE}
# create umap plots labeling by batch column
batch_umaps <- names(sce_list) %>%
  purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                     integration_method = .x,
                                     params$group_name,
                                     cell_label_column = params$batch_column,
                                     legend_title = "Batches",
                                     plot_colors = batch_colors,
                                     legend_labels = batch_plot_labels, 
                                     seed = params$seed))
batch_legend <- cowplot::get_legend(batch_umaps[[1]])
  
ggpubr::ggarrange(plotlist = batch_umaps,
                  common.legend = TRUE, 
                  legend = "right",
                  legend.grob = batch_legend, 
                  ncol = 2, 
                  nrow = 4) 
```




```{r celltype-umaps, fig.width=15, fig.height=20, warning=FALSE, message=FALSE}
# only print out celltype UMAP plot if celltype information is provided
if(celltypes_present){
 # create umap plots labeling by celltype column
  celltype_umaps <- names(sce_list) %>%
    purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                       integration_method = .x,
                                       params$group_name,
                                       cell_label_column = "celltype_plot_names", # this column includes plotting celltypes
                                       legend_title = "Cell types",
                                       plot_colors = celltype_colors,
                                       legend_labels = celltype_plot_labels,
                                       seed = params$seed))
  
  celltype_legend <- cowplot::get_legend(celltype_umaps[[1]])
  
  ggpubr::ggarrange(plotlist = celltype_umaps,
                    common.legend = TRUE, 
                    legend = "right",
                    legend.grob = celltype_legend, 
                    ncol = 2, 
                    nrow = 4) 
} else {
  warning("No cell types are present, so no cell type-annotated UMAPs will be shown.")
}
```

## Integration metrics


### iLISI

The iLISI (integration local inverse Simpson's index) metric can be used to measure the local distribution of batches in the integrated dataset, as defined in [Korsunksky et al.](https://doi.org/10.1038/s41592-019-0619-0). 
The iLISI score can be interpreted as describing how many batches are represented within a local neighborhood. 
The range of iLISI scores will be from 1 to the number of batches, however we have normalized the score following the same method utilized by the `scIB` benchmarking tools: (ilisi - 1)/(num batches -1)
Therefore, we would expect that well integrated datasets to be close to 1 indicating high mixing of batches, while poorly integrated datasets would be close to 0 indicating poor mixing.


```{r fig.height=5, fig.width=5}

ilisi_results <- run_lisi(sce_list, params$batch_column, "iLISI")

# Plot results:
print(ilisi_results$lisi_plot)
```



### cLISI

Complementary to iLISI, the cLISI (_cell type_ local inverse Simpson's index) metric can be used to measure the local distribution of cell types in the integrated dataset, as defined in [Korsunksky et al.](https://doi.org/10.1038/s41592-019-0619-0). 
The cLISI score can be interpreted as describing how many cell types are represented within a local neighborhood. 
The range of cLISI scores will be from 1 to the number of cell types, however we have normalized the score following the same method utilized by the `scIB` benchmarking tools: `(num cell types - clisi)/(num cell types - 1)`.
Therefore, we would expect that well integrated datasets to be close to 1 indicating low mixing of cell types, while poorly integrated datasets would be close to 0 indicating high mixing of cell types.


```{r, fig.height=5, fig.width=5}
if (celltypes_present) {

  clisi_results <- run_lisi(sce_list, params$celltype, "cLISI")

  # Plot results:
  print(clisi_results$lisi_plot)
} else {
  warning("No cell types are present, so cLISI scores will not be evaluated.")
}
```
  
### Batch ARI

The below plots look at the batch adjusted rand index (ARI) for each integration method.
Cells are first downsampled to 80% of the total number of cells before clustering is performed using k-means clustering.
The ARI between clustering results and batch assignments is then calculated and this is repeated 20 times.
We also calculated batch ARI across a range of k for k-means, the number of centers used for clustering.
The plots show the batch ARI on the y-axis across each integration method and value of k used for k-means clustering.
The first plot shows the integration method on the x-axis and plots are faceted by values of k, while the second plot shows each integration method as a separate plot and displays batch ARI across the range of k indicated on the x-axis.
If datasets are well integrated we would expect the batch ARI to be close to 0 and the 1-batch ARI to be close to 1, indicating that batches are well integrated across clustering assignments with low concordance between clusters and batch assignment.

```{r}
# create k range needed for input to ARI function from params

# make sure that max is not less than min
if(params$ari_k_max < params$ari_k_min){
  stop("`ari_k_max` must be greater than `ari_k_min`.")
}

## get krange
k_range <- seq(params$ari_k_min,
               params$ari_k_max,
               params$ari_k_increment)
```

```{r, warning=FALSE}
# Calculate and visualize batch ARI
batch_ari <- run_ari(sce_list, params$batch_column, k_range, params$seed)
```

```{r}
# Visualize results, faceted across k
plot(batch_ari$ari_plot_k)

# Visualize results, faceted across integration_method
plot(batch_ari$ari_plot_integration_method)
```


### Cell type ARI

The below plots look at the cell type adjusted rand index (ARI) for each integration method.
The procedure for this calculation matches that of batch ARI, except cell type labels are used as group assignments rather than batch assignments.
The plots show the cell type ARI on the y-axis across each integration method and value of k used for k-means clustering.
The first plot shows the integration method on the x-axis and plots are faceted by values of k, while the second plot shows each integration method as a separate plot and displays cell type ARI across the range of k indicated on the x-axis.
If datasets are well integrated we would expect the cell type ARI to be close to 1 and the 1-batch ARI to be close to 0, indicating that cell types are well partitioned among clustering assignments with high concordance between clusters and cell type.


```{r, warning=FALSE}
if (celltypes_present) {
  # Calculate cell type ARI, using previously-defined k_range
  celltype_ari <- run_ari(sce_list, params$celltype_column, k_range, params$seed)
  
  # Visualize results, faceted across k
  plot(celltype_ari$ari_plot_k)
  
  # Visualize results, faceted across integration_method
  plot(celltype_ari$ari_plot_integration_method)
} else {
  warning("No cell types are present, so cell type ARI will not be evaluated.")
}
```


### Within batch ARI

```{r}
# purrr across the list of integrated sce objects to compare against the integrated objects 
within_batch_ari <- purrr::imap(sce_list, 
                                \(sce, int_method){
                                  calculate_within_batch_ari(individual_sce_list,
                                                             sce,
                                                             seed = params$seed,
                                                             integration_method = int_method,
                                                             unintegrated = FALSE,
                                                             batch_column = params$batch_column)
                                }) |>
  dplyr::bind_rows()
```

```{r}
# set order of integration methods on axes
within_batch_ari <- set_integration_order(within_batch_ari)

# plot within batch ARI by integration method
ggplot(within_batch_ari, aes_string(x = "integration_method_factor" , y = "ari")) +
    ggforce::geom_sina() +
    # add median point to plot
    stat_summary(
      color = "red",
      fun = "median",
      fun.min = function(x) {
        quantile(x, 0.25)
      },
      fun.max = function(x) {
        quantile(x, 0.75)
      },
      geom = "pointrange",
      size = 0.5
    ) +
    labs(
      x = "Integration method",
      y = "ARI"
    )
```

### Batch ASW

Below we look at the batch average silhouette width (ASW) across integration methods.
Silhouette width is used to assess consistency within clusters and measures how well a given data point adheres to its own cluster vs. other clusters.
To calculate this quantity, cells are first downsampled to 80% of the total number of cells.
Batch silhouette width is calculated across 20 replicates of downsampling, and the mean silhouette widths are calculated (ASW) and shown below.
The batch silhouette width therefore measures to what extent a given data point adheres to its batch group, which is not desired after integration.
Therefore, a well-integrated dataset would show lower batch ASW values compared to an unintegrated or poorly-integrated dataset, because batches should not primarily determine clustering after successful integration.


```{r fig.height=5, fig.width=7}
asw_results <- run_asw(sce_list, 
                       params$batch_column, 
                       params$seed,
                       plot_colors = batch_colors,
                       legend_labels = batch_plot_labels)

# Plot results:
print(asw_results$asw_plot)
```


### Cell type ASW

Below we look at the cell type average silhouette width (ASW) across integration methods.
Calculations follow the same procedure as for batch ASW, except they evaluate the silhouette width across cell types rather than across batches.
A well-integrated dataset would show higher cell type ASW values compared to an unintegrated or poorly-integrated dataset, because cell types _should_ primarily determine clustering after successful integration.

Results below (if present) are shown first for all cell types together, and then shown separated by cell type.


```{r, fig.height=5, fig.width=7}
if (celltypes_present) {
  # Not separated; provide ALL celltypes here
  asw_results <- run_asw(sce_list, 
                         params$celltype_column, 
                         params$seed, 
                         by_batch = FALSE) 
  print(asw_results$asw_plot)
  
  # Separated; provide only the subtypes to plot here and their colors
  asw_results <- run_asw(sce_list, 
                         "celltype_plot_names", 
                         params$seed, 
                         by_batch = TRUE, 
                         batch_label = "Cell type", 
                         plot_colors = celltype_colors,
                         legend_labels = celltype_plot_labels) 
  print(asw_results$asw_plot)
} else {
  warning("No cell types are present, so cell type ASW will not be evaluated.")
}
```


## Session Info

```{r session_info}
sessionInfo()
```
