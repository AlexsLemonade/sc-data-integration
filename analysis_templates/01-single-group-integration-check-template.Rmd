---
params:
  group_name: "1M_Immune_Cells"
  merged_sce_dir: "../results/human_cell_atlas/merged_sce"
  integrated_sce_dir: "../results/human_cell_atlas/integrated_sce"
  batch_column: "batch"
  celltype_column: "celltype"
  num_pcs: 20
  ari_k_min: 5
  ari_k_max: 25
  ari_k_increment: 5
  num_regression_pcs: 50
  sig_threshold:  0.05
  seed: 2022
  date: !r Sys.Date()

title: "`r glue::glue('Integration evaluation for {params$group_name}')`"
author: "CCDL"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
---

## Set Up

```{r}
# load the R project
project_root <- here::here()
renv::load(project_root)
```


```{r}
suppressPackageStartupMessages({
 library(SingleCellExperiment)
 library(ggplot2)
})
theme_set(theme_bw())

set.seed(params$seed)
```


```{r setup}
utils_dir <- file.path(project_root, "scripts", "utils")

# source the helper functions to grab the integration method check
source(file.path(utils_dir, "integration-helpers.R"))

# source plotting functions
source(file.path(utils_dir, "plotting-functions.R"))

# source functions for calculating integration metrics
source(file.path(utils_dir, "calculate-batch-ARI.R"))
source(file.path(utils_dir, "calculate-batch-ASW.R"))
source(file.path(utils_dir, "calculate-iLISI.R"))
source(file.path(utils_dir, "calculate-pca-regression.R"))
```


```{r}
# build file paths for merged and integrated files
merged_sce_file <- paste0(params$group_name, "_merged_sce.rds")
merged_sce_path <- file.path(params$merged_sce_dir,
                             merged_sce_file)

# check for merged/ unintegrated SCE file
if(!file.exists(merged_sce_path)){
  stop("Merged SCE file provided does not exist")
}
```


```{r}
# find all integrated SCE files for given project
integrated_sce_files <- list.files(params$integrated_sce_dir,
                                   pattern = params$group_name,
                                   full.names = TRUE)

# extract integration methods for project from list of possible methods based on files that exist
expected_methods <- c("fastmnn", "scvi", "harmony", "scanorama", "cca", "rpca")
expected_methods_check <- paste(expected_methods, collapse = "|")
integration_methods <- stringr::str_extract(integrated_sce_files, expected_methods_check)

# check to make sure all integration methods are accounted for and have an associated file
if( !identical(sort(integration_methods), sort(expected_methods))){
  stop("All integration files are not present in provided `integrated_sce_dir`.")
}

# construct a list of all sce files for reading in merged + integrated files together
all_sce_files <- c(merged_sce_path, integrated_sce_files)

# read in rds files and create a list of all sce objects
sce_list <- purrr::map(all_sce_files, readr::read_rds) %>%
  set_names(c("unintegrated", integration_methods))
```



```{r sce-checks}

# check that batch column is found in colData of both merged and integrated sce objects
# first find all the column names of the coldata found in common
coldata_names <- sce_list %>%
    purrr::map(~ colnames(colData(.))) %>%
    unname() %>%
    unlist() %>%
    unique()

if(!params$batch_column %in% coldata_names){
  stop("Provided batch_column should be present in both the colData of the merged SCE and all integrated SCE objects.")
}


# check that umaps for pre-integrated and integrated are present
check_umap_name <- function(sce,
                            integration_method){

  if(integration_method == "unintegrated"){
    umap_name <- "UMAP"
  } else {
    # grab dim reduction name to use for plotting
    umap_name <- paste0(integration_method, "_UMAP")
  }

  if(!umap_name %in% reducedDimNames(sce)){
    missing_umap <- umap_name
  } else {
    missing_umap <- NULL
  }

  return(missing_umap)
}

missing_umap <- purrr::imap(sce_list, check_umap_name) %>%
  unlist()
if(!is.null(missing_umap)){
  stop(glue::glue("
       Missing UMAP embeddings from SCE object. Make sure that UMAP embeddings are present and labeled with {missing_umap}.
      "))
}
```

## UMAPs

```{r batch-umaps, fig.height=15, fig.width=10, warning=FALSE, message=FALSE}
# create umap plots labeling by batch column
batch_umaps <- names(sce_list) %>%
  purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                     integration_method = .x,
                                     params$group_name,
                                     cell_label_column = params$batch_column,
                                     seed = opt$seed))

  batch_legend <- cowplot::get_legend(batch_umaps[[1]])
  
  ggpubr::ggarrange(plotlist = batch_umaps,
                    common.legend = TRUE, 
                    legend = "right",
                    legend.grob = batch_legend, 
                    ncol = 2, 
                    nrow = 4) 
```


```{r celltype-umaps, fig.width=15, fig.height=20, warning=FALSE, message=FALSE}
# only print out celltype UMAP plot if celltype information is provided
if(params$celltype_column %in% coldata_names){
  # create umap plots labeling by celltype column
  celltype_umaps <- names(sce_list) %>%
    purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                       integration_method = .x,
                                       params$group_name,
                                       cell_label_column = params$celltype_column,
                                       seed = opt$seed))
  
  celltype_legend <- cowplot::get_legend(celltype_umaps[[1]])
  
  ggpubr::ggarrange(plotlist = celltype_umaps,
                    common.legend = TRUE, 
                    legend = "right",
                    legend.grob = celltype_legend, 
                    ncol = 2, 
                    nrow = 4) 

} else {
  glue::glue("
    <div class=\"alert alert-warning\">
    
    No celltype information found for this dataset.
    
    </div>
  ")
}
```

## Integration metrics

```{r}
# separate out merged sce for calculation of metrics
merged_sce <- sce_list$unintegrated
```


### iLISI

The iLISI (integration local inverse Simpson's index) metric can be used to measure the local distribution of batches in the integrated dataset, as defined in [Korsunksky et al.](https://doi.org/10.1038/s41592-019-0619-0). 
The iLISI score can be interpreted as describing how many batches are represented within a local neighborhood. 
The range of iLISI scores will be from 1 to the number of batches, however we have normalized the score following the same method utilized by the `scIB` benchmarking tools: (ilisi - 1)/(num batches -1)
Therefore, we would expect that well integrated datasets to be close to 1 indicating high mixing of batches, while poorly integrated datasets would be close to 0 indicating poor mixing.


```{r}
# calculate ilisi for unintegrated and integrated SCE separately
ilisi_unintegrated <- calculate_ilisi(merged_sce,
                                      params$batch_column,
                                      unintegrated=TRUE)

ilisi_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_ilisi(integrated_sce = sce_list[[.x]],
                                params$batch_column,
                                integration_method = .x))

# create combined DF
ilisi_df <- dplyr::bind_rows(ilisi_unintegrated, ilisi_integrated_list)
```


```{r fig.height=5, fig.width=5}
plot_ilisi(ilisi_df)
```

### Batch ARI

The below plots look at the batch adjusted rand index (ARI) for each integration method.
Cells are first downsampled to 80% of the total number of cells before clustering is performed using k-means clustering.
The ARI between clustering results and batch assignments is then calculated and this is repeated 20 times.
We also calculated batch ARI across a range of k for k-means, the number of centers used for clustering.
The plots show the batch ARI on the y-axis across each integration method and value of k used for k-means clustering.
The first plot shows the integration method on the x-axis and plots are faceted by values of k, while the second plot shows each integration method as a separate plot and displays batch ARI across the range of k indicated on the x-axis.
If datasets are well integrated we would anticipate the batch ARI to be close to 0 and the 1-batch ARI to be close to 1, indicating that batches are well integrated across clustering assignments and low concordance between clusters and batch assignment.

```{r}
# create k range needed for input to ARI function from params

# make sure that max is not less than min
if(params$ari_k_max < params$ari_k_min){
  stop("`ari_k_max` must be greater than `ari_k_min`.")
}

## get krange
k_range <- seq(params$ari_k_min,
              params$ari_k_max,
              params$ari_k_increment)
```


```{r, warning=FALSE}
# calculate batch ARI for unintegrated and integrated SCE separately
batch_ari_unintegrated <- calculate_batch_ari(merged_sce,
                                              seed = params$seed,
                                              k_range = k_range,
                                              num_pcs = params$num_pcs,
                                              unintegrated=TRUE)

batch_ari_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_batch_ari(integrated_sce = sce_list[[.x]],
                                    seed = params$seed,
                                    k_range = k_range,
                                    num_pcs = params$num_pcs,
                                    integration_method = .x))

# create combined DF
batch_ari_df <- dplyr::bind_rows(batch_ari_unintegrated, batch_ari_integrated_list)
```

```{r}
plot_batch_ari(batch_ari_df,
               facet_group = "k")
```
```{r}
plot_batch_ari(batch_ari_df,
               facet_group = "integration_method")
```


### Batch ASW

Below we look at the batch average silhouette width (ASW) across integration methods.
Silhouette width is used to assess consistency within clusters and measures how well a given data point adheres to its own cluster vs. other clusters.
To calculate this quantity, cells are first downsampled to 80% of the total number of cells.
Batch silhouette width is calculated across 20 replicates of downsampling, and the mean silhouette widths are calculated (ASW) and shown below.
The batch silhouette width therefore measures to what extent a given data point adheres to its batch group, which is not desired after integration.
Therefore, a well-integrated dataset would show lower batch ASW values compared to an unintegrated or poorly-integrated dataset, because batches should not primarily determine clustering after successful integration.

```{r}
# calculate batch ASW for unintegrated and integrated SCE separately
batch_asw_unintegrated <- calculate_batch_asw(merged_sce,
                                              seed = params$seed,
                                              num_pcs = params$num_pcs,
                                              unintegrated=TRUE)

batch_asw_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_batch_asw(integrated_sce = sce_list[[.x]],
                                    seed = params$seed,
                                    num_pcs = params$num_pcs,
                                    integration_method = .x))

# create combined DF
batch_asw_df <- dplyr::bind_rows(batch_asw_unintegrated, batch_asw_integrated_list)
```

```{r}
plot_batch_asw(batch_asw_df, seed = params$seed)
```

### PCA Regression

Below we look at two measures, PC batch variance and scaled PC regression, as derived in the [kBET manuscript](https://doi.org/10.1038/s41592-018-0254-1) (see the _Methods_ section **Principal component regression**.)
These measures can be used to assess the contribution of batches to overall variance, which we expect to be lower after successful integration, and these measures are less sensitive to bias compared to the kBET metric itself.
According to the linked manuscript, the PC batch variance approximates the "total contribution of the batch effect to the variance in the data."
As this measure may become increasingly difficult to interpret as data dimensionality increases, the additional measure, scaled PC regression, is the "sum of explained variance of all PCs" that are significantly correlated to batches, and it represents a more robust "proxy for the batch effect."
We calculate these values via downsampling to 80% of cells across 20 replicates, and results for each replicate are shown in plots below.

```{r, warning=FALSE}
# calculate PCA regression for unintegrated and integrated SCE separately
pca_unintegrated <- calculate_pca_regression(merged_sce,
                                             batch_column = params$batch_column,
                                             num_pcs = params$num_regression_pcs,
                                             significance_threshold = params$sig_threshold,
                                             seed = params$seed,
                                             unintegrated=TRUE)

pca_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_pca_regression(integrated_sce = sce_list[[.x]],
                                         batch_column = params$batch_column,
                                         num_pcs = params$num_regression_pcs,
                                         significance_threshold = params$sig_threshold,
                                         seed = params$seed,
                                         integration_method = .x))

# create combined DF
pca_df <- dplyr::bind_rows(pca_unintegrated, pca_integrated_list)
```

```{r, fig.height = 4, fig.width = 6}
plot_pca_regression(pca_df, seed = params$seed)
```

## Session Info

```{r session_info}
sessionInfo()
```
