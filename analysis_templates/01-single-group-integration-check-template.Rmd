---
params:
  group_name: "1M_Immune_Cells"
  merged_sce_dir: "../results/human_cell_atlas/merged_sce"
  integrated_sce_dir: "../results/human_cell_atlas/integrated_sce"
  batch_column: "batch"
  celltype_column: "celltype"
  num_pcs: 20
  ari_k_min: 5
  ari_k_max: 25
  ari_k_increment: 5
  k0_fraction_min: 0.05
  k0_fraction_max: 0.25
  k0_fraction_increment: 0.05
  num_regression_pcs: 50
  sig_threshold:  0.05
  seed: 2022
  date: !r Sys.Date()

title: "`r glue::glue('Integration evaluation for {params$group_name}')`"
author: "CCDL"
date: "`r params$date`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
---

## Set Up

```{r}
# load the R project
project_root <- here::here()
renv::load(project_root)
```


```{r}
suppressPackageStartupMessages({
 library(SingleCellExperiment)
 library(ggplot2) 
})
theme_set(theme_bw())

set.seed(params$seed)
```


```{r setup}
utils_dir <- file.path(project_root, "scripts", "utils")

# source the helper functions to grab the integration method check 
source(file.path(utils_dir, "integration-helpers.R"))

# source plotting functions
source(file.path(utils_dir, "plotting-functions.R"))

# source functions for calculating integration metrics 
source(file.path(utils_dir, "calculate-batch-ARI.R"))
source(file.path(utils_dir, "calculate-batch-ASW.R"))
source(file.path(utils_dir, "calculate-iLISI.R"))
source(file.path(utils_dir, "calculate-kBET.R"))
source(file.path(utils_dir, "calculate-pca-regression.R"))
```


```{r}
# build file paths for merged and integrated files 
merged_sce_file <- paste0(params$group_name, "_merged_sce.rds")
merged_sce_path <- file.path(params$merged_sce_dir, 
                             merged_sce_file)

# check for merged/ unintegrated SCE file
if(!file.exists(merged_sce_path)){
  stop("Merged SCE file provided does not exist")
}
```


```{r}
# find all integrated SCE files for given project 
integrated_sce_files <- list.files(params$integrated_sce_dir,
                                   pattern = params$group_name,
                                   full.names = TRUE)

# extract integration methods for project from list of possible methods based on files that exist
expected_methods <- c("fastmnn", "scvi", "harmony", "scanorama", "cca", "rpca")
expected_methods_check <- paste(expected_methods, collapse = "|")
integration_methods <- stringr::str_extract(integrated_sce_files, expected_methods_check)

# check to make sure all integration methods are accounted for and have an associated file
if( !identical(sort(integration_methods), sort(expected_methods))){
  stop("All integration files are not present in provided `integrated_sce_dir`.")
}

# construct a list of all sce files for reading in merged + integrated files together
all_sce_files <- c(merged_sce_path, integrated_sce_files)

# read in rds files and create a list of all sce objects
sce_list <- purrr::map(all_sce_files, readr::read_rds) %>%
  set_names(c("unintegrated", integration_methods))
```



```{r sce-checks}

# check that batch column is found in colData of both merged and integrated sce objects
# first find all the column names of the coldata found in common
coldata_names <- sce_list %>%
    purrr::map(~ colnames(colData(.))) %>%
    unname() %>%
    unlist() %>%
    unique()

if(!params$batch_column %in% coldata_names){
  stop("Provided batch_column should be present in both the colData of the merged SCE and all integrated SCE objects.")
}

if(!params$celltype_column %in% coldata_names){
  stop("Provided celltype_column should be present in both the colData of the merged SCE and all integrated SCE objects.")
}


# check that umaps for pre-integrated and integrated are present
check_umap_name <- function(sce,
                            integration_method){
  
  if(integration_method == "unintegrated"){
    umap_name <- "UMAP"
  } else {
    # grab dim reduction name to use for plotting 
    umap_name <- paste0(integration_method, "_UMAP") 
  }
  
  if(!umap_name %in% reducedDimNames(sce)){
    missing_umap <- umap_name
  } else {
    missing_umap <- NULL
  }
  
  return(missing_umap)
}

missing_umap <- purrr::imap(sce_list, check_umap_name) %>%
  unlist()
if(!is.null(missing_umap)){
  stop(glue::glue("
       Missing UMAP embeddings from SCE object. Make sure that UMAP embeddings are present and labeled with {missing_umap}.
       
       "))
}
```

## UMAPs

```{r batch-umaps, fig.height=20, fig.width=10}
# create umap plots labeling by batch column
batch_umaps <- names(sce_list) %>%
  purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                      integration_method = .x,
                                      params$group_name,
                                      cell_label_column = params$batch_column))
gridExtra::grid.arrange(grobs = batch_umaps, ncol = 2)
```

```{r celltype-umaps, fig.width=10, fig.height=20}
# create umap plots labeling by celltype column
celltype_umaps <- names(sce_list) %>%
  purrr::map(~ plot_integration_umap(sce = sce_list[[.x]],
                                      integration_method = .x,
                                      params$group_name,
                                      cell_label_column = params$celltype_column))
gridExtra::grid.arrange(grobs = celltype_umaps, ncol = 2)
```

## Integration metrics 

```{r}
# separate out merged sce for calculation of metrics 
merged_sce <- sce_list$unintegrated
```


### iLISI

```{r}
# calculate ilisi for unintegrated and integrated SCE separately
ilisi_unintegrated <- calculate_ilisi(merged_sce,
                                      params$batch_column,
                                      unintegrated=TRUE)

ilisi_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_ilisi(integrated_sce = sce_list[[.x]],
                                params$batch_column,
                                integration_method = .x))

# create combined DF 
ilisi_df <- dplyr::bind_rows(ilisi_unintegrated, ilisi_integrated_list)
```


```{r}
head(ilisi_df)
```

### Batch ARI
```{r}
# create k range needed for input to ARI function from params 

# make sure that max is not less than min 
if(params$ari_k_max < params$ari_k_min){
  stop("`ari_k_max` must be greater than `ari_k_min`.")
}

## get krange 
k_range <- seq(params$ari_k_min,
              params$ari_k_max,
              params$ari_k_increment)
```


```{r}
# calculate batch ARI for unintegrated and integrated SCE separately
batch_ari_unintegrated <- calculate_batch_ari(merged_sce,
                                              seed = params$seed,
                                              k_range = k_range,
                                              num_pcs = params$num_pcs,
                                              unintegrated=TRUE)

batch_ari_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_batch_ari(integrated_sce = sce_list[[.x]],
                                    seed = params$seed,
                                    k_range = k_range,
                                    num_pcs = params$num_pcs,
                                    integration_method = .x))

# create combined DF 
batch_ari_df <- dplyr::bind_rows(batch_ari_unintegrated, batch_ari_integrated_list)
```

```{r}
head(batch_ari_df)
```
### Batch ASW

```{r}
# calculate batch ASW for unintegrated and integrated SCE separately
batch_asw_unintegrated <- calculate_batch_asw(merged_sce,
                                              seed = params$seed,
                                              num_pcs = params$num_pcs,
                                              unintegrated=TRUE)

batch_asw_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_batch_asw(integrated_sce = sce_list[[.x]],
                                    seed = params$seed,
                                    num_pcs = params$num_pcs,
                                    integration_method = .x))

# create combined DF 
batch_asw_df <- dplyr::bind_rows(batch_asw_unintegrated, batch_asw_integrated_list)

```

```{r}
head(batch_asw_df)
```

### kBET 

```{r}
# create k range needed for input to ARI function from params 

# make sure that max is not less than min 
if(params$k0_fraction_max < params$k0_fraction_min){
  stop("`k0_fraction_max` must be greater than `k0_fraction_min`.")
}

## get krange 
k0_fraction_range <- seq(params$k0_fraction_min,
                         params$k0_fraction_max,
                         params$k0_fraction_increment)
```


```{r}
# calculate kBET for unintegrated and integrated SCE separately
kbet_unintegrated <- calculate_kbet(merged_sce,
                                    params$batch_column,
                                    seed = params$seed,
                                    num_pcs = params$num_pcs,
                                    k0_fraction_range = k0_fraction_range,
                                    unintegrated=TRUE)

kbet_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_kbet(integrated_sce = sce_list[[.x]],
                               params$batch_column,
                               seed = params$seed,
                               num_pcs = params$num_pcs,
                               k0_fraction_range = k0_fraction_range,
                               integration_method = .x))

# create combined DF 
kbet_df <- dplyr::bind_rows(kbet_unintegrated, kbet_integrated_list)

```

```{r}
head(kbet_df)
```


### PCA Regression

```{r}
# calculate PCA regression for unintegrated and integrated SCE separately
pca_unintegrated <- calculate_pca_regression(merged_sce,
                                             batch_column = params$batch_column,
                                             num_pcs = params$num_regression_pcs,
                                             significance_threshold = params$sig_threshold,
                                             seed = params$seed,
                                             unintegrated=TRUE)

pca_integrated_list <- integration_methods %>%
  purrr::imap(~ calculate_pca_regression(integrated_sce = sce_list[[.x]],
                                         batch_column = params$batch_column,
                                         num_pcs = params$num_regression_pcs,
                                         significance_threshold = params$sig_threshold,
                                         seed = params$seed,
                                         integration_method = .x))

# create combined DF 
pca_df <- dplyr::bind_rows(pca_unintegrated, pca_integrated_list)
```

```{r}
head(pca_df)
```

## Session Info

```{r session_info}
sessionInfo()
```
