---
params:
  seed: 2022
  library_file: !r file.path("sample-info", "scpca-processed-libraries.tsv")
  project_id: "SCPCP000007"
  reference: "hpca"
  integrated_sce_dir: !r file.path("results", "scpca", "integrated_sce")
  integration_method: "fastmnn"
  max_celltypes: 5
title: "Cell type annotation exploration"
author: "Data Lab"
date: "`r params$date`"
output:
  html_notebook:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This notebook explores the use of [`SingleR`](https://bioconductor.org/books/release/SingleRBook/) to perform cell-type annotation on datasets from the ScPCA project SCPCP000007 (Gawad lab data).

**Note:** The first time you run this code it may take a few more minutes due to reference downloads, but they will be cached for faster future execution.

## Set Up

Use this code to obtain the PBMC reference from Zenodo: https://zenodo.org/record/4546839#.Y3PZ5oLMJhE
```{sh, eval=FALSE}
wget https://zenodo.org/record/4546839/files/ref.Rds
```


```{r setup}
# load the R project
project_root <- here::here()
renv::load(project_root)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(SingleR)
  library(celldex)
  library(ggplot2)
})
theme_set(theme_bw())
set.seed(params$seed) # unclear if this is doing anything? probably not. but maybe later!

utils_dir <- file.path(project_root, "scripts", "utils")
source(file.path(utils_dir, "integration-helpers.R"))

sce_file_suffix <- "processed_citeseq.rds"

integrated_sce_file <- file.path(project_root, 
                                 params$integrated_sce_dir, 
                                 paste0(params$project_id, "_integrated_", params$integration_method, "_sce.rds")
                                 )
if (!file.exists(integrated_sce_file)){
  stop("Integrated SCE file could not be found.")
}
```

Read in the data:

```{r}
library_metadata_df <- readr::read_tsv(file.path(project_root, params$library_file))

integrated_sce <- readr::read_rds(integrated_sce_file)

# Define the unintegrated SCE filenames
sce_file_paths <- library_metadata_df %>%
  dplyr::filter(project_name == params$project_id) %>%
  dplyr::mutate(sce_file_path = file.path(
    project_root, 
    integration_input_dir, 
    sample_biomaterial_id, 
    glue::glue("{library_biomaterial_id}_{sce_file_suffix}")
  )) %>%
  dplyr::pull(sce_file_path)
```


## `SingleR` annotation

Here we perform celltype annotation with the given reference in `params$reference` on each of the Gawad libraries and look at their UMAPs colored by celltype.

First, set the reference:
```{r}
if (params$reference == "hpca") {
  ref_data <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE)
} else if (params$reference == "blueprint_encode") {
  ref_data <- celldex::BlueprintEncodeData(ensembl = TRUE)
} else {
  stop("Bad reference parameter; either 'hpca' or 'blueprint_encode'.")
}
```

Define some functions:
```{r}
annotate_SingleR <- function(sce, ref_data, label_name = "label.main") {
  # label_name is either "label.main" or "label.fine" to label with reference
  #  broad or fine-grained celltypes, respectively
  
  #label_name <- "label.fine"
  # return updated sce and the predictions themselves
  preds <- SingleR::SingleR(
    test = sce, 
    ref = ref_data,
    labels = colData(ref_data)[,label_name], 
    BPPARAM = BiocParallel::MulticoreParam(4)
  )
  
  # Add `pruned.labels`, where low-confidence annotations are NA, to sce
   sce$SingleR_annotations <- preds$pruned.labels
  
   return(
     list(
       sce = sce,
       preds = preds
       )
   )
}

plot_SingleR <- function(annotation_output, colname) {
  # annotation_output: list of sce and preds
  # colname: column name to plot
  # Make a heatmap and UMAP and print them out
  
  heatmap <- SingleR::plotScoreHeatmap(annotation_output[["preds"]], 
                                       # default but let's be explicit
                                       show.pruned = FALSE)

  
  # In case, for `levels()` below.
  colData(annotation_output[["sce"]])[,colname] <- as.factor(colData(annotation_output[["sce"]])[,colname])
  
  umap_df <- tibble::as_tibble(reducedDim(annotation_output[["sce"]], "UMAP")) %>%
    dplyr::select(UMAP1 = V1, UMAP2 = V2) %>%
    dplyr::mutate(celltypes = colData(annotation_output[["sce"]])[,colname])
  
  plot_colors <- rainbow( length(levels(umap_df$celltypes)) )
  
  umap <- ggplot(umap_df) + 
    aes(x = UMAP1, y = UMAP2, color = celltypes) +
    geom_point(size = 0.2, alpha = 0.5) + 
    scale_color_manual(values = plot_colors) +
    guides(color = guide_legend(override.aes = list(size=3))) +
    ggtitle(glue::glue("UMAP with top {params$max_celltypes} celltypes shown"))
  
  print(heatmap)
  print(umap)
  
}

# Function to run and plot SingleR
# Return SCE with annotations `SingleR_annotations` column
run_SingleR <- function(sce, 
                        max_celltypes = params$max_celltypes, 
                        viz = TRUE) {
  # Print out the library
  print(unique( metadata(sce)$library ))
  
  # Run annotations
  anno <- annotate_SingleR(sce, ref_data)
  
  # Create an additional column `SingleR_annotations_collapsed` with only max_celltypes
  anno[["sce"]]$SingleR_annotations_collapsed <- forcats::fct_lump_n(
    anno[["sce"]]$SingleR_annotations, 
    max_celltypes
  )
  
  # plot if TRUE
  if (viz) {
    # there is no interesting color palette harmonization among library colors here!
    plot_SingleR(anno, "SingleR_annotations_collapsed")
  }
  return(anno[["sce"]])
}
```

Here we go!

```{r}
# Read in all SCE files
sce_list <- purrr::map(
  sce_file_paths, 
  readr::read_rds
)

# Annotate them all, popping out some viz along the way if specified
sce_list_annotated <- purrr::map(sce_list, run_SingleR, viz = TRUE)
```

## UMAPs

This section has some UMAPs:

- Celltype annotations from individual libraries applied to the integrated UMAP
- ADT levels on the integrated UMAP for some proteins of interest: `CD123` (leukemia marker) and `CD3` (T-cell marker)


```{r}
# First let's create a df of celltypes and ADTs:
extract_celltypes_adts <- function(sce) {
  # data frame of ADT counts
  adt_df <- logcounts(altExp(sce)) %>%
    as.matrix() %>%
    t() %>%
    tibble::as_tibble(rownames = "cell_barcode") %>%
    tidyr::pivot_longer(dplyr::starts_with("CD"),
                        names_to = "ADT", 
                        values_to = "logcounts")
  
  # Combine with data frame of annotations
  tibble::tibble(celltype = sce$SingleR_annotations, 
                 cell_barcode = rownames(colData(sce)),
                 library = metadata(sce)$library) %>%
    dplyr::inner_join(adt_df) %>%
    dplyr::mutate(cell_name = paste(cell_barcode, library, sep = "-"))
}

celltype_adt_df <- purrr::map_df(sce_list_annotated, extract_celltypes_adts)


# integrated UMAP with individual library cell annotations colored
umap_df <- celltype_adt_df %>%
  dplyr::select(celltype, cell_name, library) %>%
  dplyr::distinct() %>%
  dplyr::bind_cols(
    as.data.frame(reducedDim(integrated_sce, paste0(params$integration_method, "_UMAP")))
  ) %>%
  dplyr::mutate(UMAP1 = V1, 
                UMAP2 = V2,
                celltype = forcats::fct_lump_n(celltype, params$max_celltypes))

# And let's make a UMAP!
rna_umap <- ggplot(umap_df) +
  aes(x = UMAP1, y = UMAP2, color = celltype) + 
  geom_point(size = 0.3, alpha = 0.4) + 
  guides(color = guide_legend(override.aes = list(size=3))) +
  ggtitle(glue::glue("Integrated UMAP with top {params$max_celltypes} SingleR-annotated celltypes shown"))

rna_umap
```
```{r}
rna_umap +
  lims(
    x = c(-6, 4), 
    y = c(-5, 5.5)
  ) +
  ggtitle("The above UMAP, zoomed in")
```


```{r}
# function to make UMAPs colored by ADT
make_adt_umap <- function(celltype_adt_df, adt_name) {
  
  umap_df <- celltype_adt_df %>%
    dplyr::select(cell_name, ADT, logcounts) %>%
    dplyr::filter(ADT %in% adt_name) %>%
    dplyr::bind_cols(
      as.data.frame(reducedDim(integrated_sce, paste0(params$integration_method, "_UMAP")))
    ) %>%
    dplyr::rename(UMAP1 = V1, 
                  UMAP2 = V2)
  
  ggplot(umap_df) + 
    aes(x = UMAP1, y = UMAP2, color = logcounts) + 
    geom_point(size = 0.3, alpha = 0.4) +
    scale_color_viridis_c() + 
    labs(
      title = glue::glue("{adt_name} expression"),
      color = "Normalized expression")
}

make_adt_umap(celltype_adt_df, "CD3") # bottom left corner tiny dots!
make_adt_umap(celltype_adt_df, "CD123") # everything is tumor
make_adt_umap(celltype_adt_df, "CD45") # should be on all differentiated cells more or less\
make_adt_umap(celltype_adt_df, "CD19") # b cells

```


## Comparing references

To build a sense of how different references perform, let's just look at one SCE (arbitrarily chosen as the first):

```{r}
sce <- sce_list[[1]]
```


Functions for comparing references:
```{r}
# Return a tibble of predictions from the two references

# Define outside of function to avoid rerunning over and over and over AND OVER.
hpca_ref <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE)
blueprint_encode_ref <- celldex::BlueprintEncodeData(ensembl = TRUE)

compare_predictions <- function(sce, 
                                label_name) {
  
  # HPCA prediction
  preds_hpca <- SingleR::SingleR(
    test = sce, 
    ref = hpca_ref,
    labels = colData(hpca_ref)[,label_name], 
    BPPARAM = BiocParallel::MulticoreParam(4)
  )
  
  # Blueprint/ENCODE prediction
  preds_be <- SingleR::SingleR(
    test = sce, 
    ref = blueprint_encode_ref,
    labels = colData(blueprint_encode_ref)[,label_name], 
    BPPARAM = BiocParallel::MulticoreParam(4)
  )
  
  # Combine results into a wide tibble:
  preds_df <- tibble::tibble(
    hpca = preds_hpca$labels, 
    cell_barcode = rownames(preds_hpca)) %>%
    dplyr::inner_join(
      tibble::tibble(
        blueprint_encode = preds_be$labels, 
        cell_barcode = rownames(preds_be)) 
    )

  return(preds_df)
}
```

The [`celldex`]((https://bioconductor.org/packages/release/data/experiment/vignettes/celldex/inst/doc/userguide.html)) package contains bulk RNA-Seq datasets for use as reference.
These two are likely most useful:

> The HPCA reference consists of publicly available microarray datasets derived from human primary cells (Mabbott et al. 2013). Most of the labels refer to blood subpopulations but cell types from other tissues are also available.


> The Blueprint/ENCODE reference consists of bulk RNA-seq data for pure stroma and immune cells generated by Blueprint (Martens and Stunnenberg 2013) and ENCODE projects (The ENCODE Project Consortium 2012).



```{r}
main_labels_df <- compare_predictions(sce, "label.main")
fine_labels_df <- compare_predictions(sce, "label.fine")

```

How do these predictions compare?
Note that these references often use different labels for the same cell type so we shouldn't expect a perfect diagonal below:

```{r}
#function for making comparison heatmaps
make_comparison_heatmap <- function(df) {
  df %>%
    dplyr::mutate(
      hpca = forcats::fct_rev(forcats::fct_infreq(hpca)),
      blueprint_encode = forcats::fct_rev(forcats::fct_infreq(blueprint_encode))
    ) %>%
    dplyr::count(hpca, blueprint_encode) %>%
  ggplot() + 
  aes(x = blueprint_encode, y = hpca, fill = n) + 
  geom_tile(color = "black") + 
  geom_text(aes(label = n)) + 
  scale_fill_distiller(palette = "RdYlBu", name = "Num. cells") + 
  # background grid from theme_bw does not match up with rectangles.
  theme_classic() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))
}
```

```{r fig.height=3, fig.width=5}
make_comparison_heatmap(main_labels_df) + ggtitle("Broad label comparison")
```

```{r fig.height=6, fig.width=8}
make_comparison_heatmap(fine_labels_df) + ggtitle("Fine label comparison")
```




## Session Info

```{r session_info}
sessionInfo()
```
