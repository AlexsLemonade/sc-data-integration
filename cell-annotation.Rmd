---
params:
  seed: 2022
  library_file: !r file.path("sample-info", "scpca-processed-libraries.tsv")
  reference: "hpca"
title: "Cell type annotation exploration"
author: "Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
editor_options: 
  chunk_output_type: console
---

This notebook explores the use of [`SingleR`](https://bioconductor.org/books/release/SingleRBook/) to perform cell-type annotation on datasets from the ScPCA project SCPCP000007 (Gawad lab data).

**Note:** The first time you run this code it may take a few more minutes due to reference downloads, but they will be cached for faster future execution.

## Set Up

```{r setup}
# load the R project
project_root <- here::here()
renv::load(project_root)

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(SingleR)
  library(celldex)
  library(ggplot2)
})
theme_set(theme_bw())
set.seed(params$seed) # unclear if this is doing anything? probably not. but maybe later!

utils_dir <- file.path(project_root, "scripts", "utils")

# source the helper functions to grab the integration method check
source(file.path(utils_dir, "integration-helpers.R"))

gawad_project_id <- "SCPCP000007"
sce_file_suffix <- "processed_citeseq.rds"
```

Read in the data:

```{r}
library_metadata_df <- readr::read_tsv(params$library_file)

# Define the SCE filenames
sce_file_paths <- library_metadata_df %>%
  dplyr::filter(project_name == gawad_project_id) %>%
  dplyr::mutate(sce_file_path = file.path(
    integration_input_dir, sample_biomaterial_id, glue::glue("{library_biomaterial_id}_{sce_file_suffix}")
  )) %>%
  dplyr::pull(sce_file_path)
```


## Initial exploration

> Currently the code chunks in this section are not evaluated, but remain here for now for posterity.

To build an initial sense of what we can expect annotating with `SingleR`, let's just look at one SCE (arbitrarily chosen as the first):

```{r, eval=F}
# For now let's just explore one!
sce_file <- sce_file_paths[[1]]

sce <- readr::read_rds(sce_file)
sce
```


The `celldex` package contains bulk RNA-Seq datasets for use as reference.
Since this is AML data, we'll want a reference that has a lot of blood information.
According to the [`celldex`](https://bioconductor.org/packages/release/data/experiment/vignettes/celldex/inst/doc/userguide.html), the `Human Primary Cell Atlas` data will be our closest match.

> The HPCA reference consists of publicly available microarray datasets derived from human primary cells (Mabbott et al. 2013). Most of the labels refer to blood subpopulations but cell types from other tissues are also available.


```{r, eval=F}
# define reference with ensembl IDs to match our IDs
ref_se <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE)

# Predict cell types
#  If we change to `labels = ref_se$label.fine`, we'll get more 
#  fine-grained annotations with subtypes etc.
preds_hpca <- SingleR::SingleR(
  # dataset we want to annotate
  test = sce, 
  # reference dataset
  ref = ref_se,
  # label.main is broad 
  labels = ref_se$label.main)


# Results into a tibble:
preds_df <- tibble::as_tibble(preds_hpca$labels) %>%
  dplyr::rename(celltype = value) %>%
  dplyr::mutate(cell_barcode = rownames(preds_hpca),
                reference = "hpca")

# Save the celltypes:
hpca_celltypes <- unique(ref_se$label.main)
```

And a heatmap version, showing all celltypes. 
The bar the top shows the final assignment, which are the rows with highest scores.

```{r, eval=F, fig.width = 8, fig.height = 5}
SingleR::plotScoreHeatmap(preds_hpca)
```

But can't hurt to see how this compares to the `Blueprint/ENCODE` reference:

> The Blueprint/ENCODE reference consists of bulk RNA-seq data for pure stroma and immune cells generated by Blueprint (Martens and Stunnenberg 2013) and ENCODE projects (The ENCODE Project Consortium 2012).


```{r, eval=F, fig.width = 8, fig.height = 5}
# define reference with ensembl IDs to match our IDs
ref_se <- celldex::BlueprintEncodeData(ensembl = TRUE)

# Predict cell types, broadly
preds_blue_enc <- SingleR::SingleR(
  # dataset we want to annotate
  test = sce, 
  # reference dataset
  ref = ref_se,
  # label.main is broad 
  labels = ref_se$label.main)


# Results into a tibble:
preds_df <- preds_df %>%
  dplyr::bind_rows(
    tibble::as_tibble(preds_blue_enc$labels) %>%
    dplyr::rename(celltype = value) %>%
    dplyr::mutate(cell_barcode = rownames(preds_blue_enc),
                  reference = "blueprint_encode")
  )

# Save the celltypes:
blueprint_celltypes <- unique(ref_se$label.main)

# And the heatmap:
SingleR::plotScoreHeatmap(preds_blue_enc)
```


What did the references predict?


```{r, eval=F}
# How many of each celltype?
preds_df %>%
  dplyr::filter(reference == "hpca") %>%
  dplyr::count(celltype) %>%
  dplyr::arrange(-n)


preds_df %>%
  dplyr::filter(reference == "blueprint_encode") %>%
  dplyr::count(celltype) %>%
  dplyr::arrange(-n)
```

We'll have to harmonize the celltype names between references to do a robust comparison, but from a _very_ quick glance, overlap is thinner than one might like.
That said, we don't necessarily expect Blueprint/ENCODE to do particularly well anyways!


For a clearer comparison, we'll harmonize predicted celltypes, but let's just focus on exactly matching celltypes as a start - 
```{r, eval=F}
# Let's see what we have here:
sort(hpca_celltypes)
sort(blueprint_celltypes)

# Manually compiled data rame of celltypes roughly present in BOTH references
#  for now leaving the Pre/Pro B-cells out
shared_celltypes_df <- tibble::tribble(
  ~hpca_celltype, ~blueprint_celltype,
  # Both references have it:
  "Astrocyte", "Astrocytes",
  "B_cell", "B-cells",
  "Chondrocytes","Chondrocytes",
  "DC", "DC", 
  "Endothelial_cells", "Endothelial cells", 
  "Epithelial_cells", "Epithelial cells", 
  "Fibroblasts", "Fibroblasts", 
  "Keratinocytes", "Keratinocytes", 
  "Macrophage", "Macrophages", 
  "Monocyte", "Monocytes", 
  "Neurons", "Neurons", 
  "Neutrophils", "Neutrophils", 
  "NK_cell", "NK cells", 
  "Smooth_muscle_cells", "Smooth muscle", 
  # two groups - collapse back to overall T cells
  "T_cells", "CD8+ T-cells",
  "T_cells", "CD4+ T-cells",
  # two groups of HSCs, again, collapse back to overall
  "HSC_-G-CSF", "HSC", 
  "HSC_CD34+", "HSC"
) %>%
  dplyr::mutate(harmonized_celltype = ifelse(blueprint_celltype == "HSC",
                                             blueprint_celltype, 
                                             hpca_celltype))

harmonize_celltypes <- function(preds_df, reference_name) {
  if (reference_name == "hpca") {
    shared_celltypes_colname <- rlang::sym("hpca_celltype")
  } else {
    shared_celltypes_colname <- rlang::sym("blueprint_celltype")
  }
  
  filtered_preds_df <- preds_df %>%
    dplyr::filter(reference == reference_name) 
  
  sym_reference_name <- rlang::sym(reference_name)
  filtered_preds_df %>%
    dplyr::inner_join(
      dplyr::select(
        shared_celltypes_df, 
        celltype = {{shared_celltypes_colname}},
        harmonized_celltype
      )
    ) %>% 
    dplyr::select(cell_barcode, {{sym_reference_name}} := harmonized_celltype) %>%
    dplyr::right_join(filtered_preds_df) %>%
    dplyr::mutate({{reference_name}} := dplyr::if_else(
      {{sym_reference_name}} %in% shared_celltypes_df$harmonized_celltype,
      {{sym_reference_name}},
      celltype
    )) %>% 
    dplyr::select(-celltype, -reference)
  }
  
preds_df_harmonized <- harmonize_celltypes(preds_df, "blueprint_encode") %>%
  dplyr::left_join(
    harmonize_celltypes(preds_df, "hpca")  
  )

# How often do they match?

preds_df_harmonized %>%
  dplyr::summarize(percent_same = sum(blueprint_encode == hpca) / dplyr::n() )


# Where do they not match?
preds_df_harmonized %>%
  dplyr::filter(hpca != blueprint_encode)
  
# Are there specific combinations that get differently annotated?
preds_df_harmonized %>%
  dplyr::filter(hpca != blueprint_encode) %>%
  dplyr::select(-cell_barcode) %>%
  dplyr::count(blueprint_encode, hpca) %>%
  dplyr::arrange(-n)

```

## Let's get to it!


Now, let's do cell type annotation with the given reference in `params$reference` on each of the Gawad libraries and look at their UMAPs colored by celltype.

```{r}
if (params$reference == "hpca") {
  ref_data <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE)
} else if (params$reference == "blueprint_encode") {
  ref_data <- celldex::BlueprintEncodeData(ensembl = TRUE)
} else {
  stop("Bad reference parameter; either 'hpca' or 'blueprint_encode'.")
}


annotate_SingleR <- function(sce, ref_data) {
  # return updated sce and the predictions themselves
  
  preds <- SingleR::SingleR(
    test = sce, 
    ref = ref_data,
    labels = ref_data$label.main
  )
  
  # Add `pruned.labels`, where low-confidence annotations are NA, to sce
   sce$SingleR_annotations <- preds$pruned.labels
   
   return(
     list(
       sce = sce,
       preds = preds
       )
   )
}

plot_SingleR <- function(annotation_output) {
  # annotation_output: list of sce and preds
  # Make a heatmap and UMAP and print out
  
  heatmap <- SingleR::plotScoreHeatmap(annotation_output[["preds"]], 
                                       # default but let's be explicit
                                       show.pruned = FALSE)

  
  umap_df <- tibble::as_tibble(reducedDim(annotation_output[["sce"]], "UMAP")) %>%
    dplyr::select(UMAP1 = V1, UMAP2 = V2) %>%
    dplyr::mutate(celltypes = annotation_output[["sce"]]$SingleR_annotations)
  
  # We would probably like a more principled approach to colors that is
  #  actually based on biological information about celltypes
  plot_colors <- rainbow( length(unique(umap_df$celltypes[!(is.na(umap_df$celltypes))])))
  
  umap <- ggplot(umap_df) + 
    aes(x = UMAP1, y = UMAP2, color = celltypes) +
    geom_point(size = 0.2, alpha = 0.5) + 
    scale_color_manual(values = plot_colors)
  
  print(heatmap)
  print(umap)
  
}

# Function to run and plot SingleR
# Return SCE with annotations `SingleR_annotations` column
run_SingleR <- function(sce, viz = TRUE) {
  # Print out the library
  print(unique( metadata(sce)$library ))
  
  # Run and plot (if TRUE) annotations
  anno <- annotate_SingleR(sce, ref_data)
  if (viz) {
    # there is no interesting color palette harmonization among library colors here!
    plot_SingleR(anno)
  }
  return(anno[["sce"]])
}
```

Here we go!

```{r}

# Read in all SCE files
sce_list <- purrr::map(
  sce_file_paths, 
  readr::read_rds
)

# Annotate them all, popping out some viz along the way
singler_sce_list <- purrr::map(sce_list, run_SingleR, viz = TRUE)
```



Now let's plot, to start, the fastMNN UMAP but with celltype annotations from individual libraries.
As is deeply commented all over the place, we definitely need to infuse palettes with biology!

```{r}
# helper to count the number of celltypes across all libraries
count_celltypes <- function(sce) {
 tibble::tibble(celltype = colData(sce)$SingleR_annotations ) %>%
    dplyr::count(celltype) %>%
    dplyr::arrange(-n) %>%
    tidyr::drop_na() 
}

# Celltype order based on **overall** counts for all pooled annotations 
celltype_order <- purrr::map_df(singler_sce_list, count_celltypes) %>%
  dplyr::group_by(celltype) %>%
  dplyr::summarize(celltype_counts = sum(n)) %>%
  dplyr::arrange(-celltype_counts) %>%
  dplyr::pull(celltype)


# Again we'd eventually like some biology to go into the color choices!
cell_colors <- rainbow(length(celltype_order))

# Read in an integrated SCE just to start getting a sense
fastmnn <- readr::read_rds(file.path("results", "scpca", "integrated_sce", 
                                     paste0(gawad_project_id, "_integrated_fastmnn_sce.rds" ))
)


# Find all the celltype annotations for a combined color palette:
extract_celltypes <- function(sce) {
 tibble::tibble(batch = unique(metadata(sce)$library),
                celltype = colData(sce)$SingleR_annotations, 
                cell_barcode = rownames(colData(sce))) %>%
    dplyr::mutate(cell_name = paste(cell_barcode, batch, sep = "-"))
}

# fastMNN UMAP with individual library cell annotations colored
purrr::map_df(singler_sce_list, extract_celltypes) %>%
  dplyr::inner_join(
    tibble::as_tibble(colData(fastmnn), rownames = "cell_name")
  ) %>%
  dplyr::bind_cols(
    as.data.frame(reducedDim(fastmnn, "fastmnn_UMAP"))
  ) %>%
  dplyr::mutate(UMAP1 = V1, UMAP2 = V2) %>%
  # And let's make a UMAP!
  ggplot() +
  aes(x = UMAP1, y = UMAP2, color = celltype) + 
  geom_point(size = 0.2, alpha = 0.3) + 
  # we definitely want some biology here!
  scale_color_manual(values = cell_colors)
```




## Session Info

```{r session_info, eval=TRUE}
sessionInfo()
```
