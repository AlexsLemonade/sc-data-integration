---
params:
  seed: 2022
  library_file: !r file.path("sample-info", "scpca-processed-libraries.tsv")
title: "Cell type annotation exploration"
author: "Data Lab"
date: "`r params$date`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This notebook explores the use of [`SingleR`](https://bioconductor.org/books/release/SingleRBook/) to perform cell-type annotation on datasets from the ScPCA project SCPCP000007 (Gawad lab data).

**Note:** The first time you run this code it may take a few more minutes due to reference downloads, but they will be cached for faster future execution.

## Set Up

```{r}
# load the R project
project_root <- here::here()
renv::load(project_root)
```


```{r}
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(SingleR)
  library(celldex)
})

set.seed(params$seed) # unclear if this is doing anything? probably not. but maybe later!
```


```{r setup}
utils_dir <- file.path(project_root, "scripts", "utils")

# source the helper functions to grab the integration method check
source(file.path(utils_dir, "integration-helpers.R"))

gawad_project_id <- "SCPCP000007"
sce_file_suffix <- "processed_citeseq.rds"
```

Read in the data:

```{r}
library_metadata_df <- readr::read_tsv(params$library_file)

# Define the SCE filenames
sce_file_paths <- library_metadata_df %>%
  dplyr::filter(project_name == gawad_project_id) %>%
  dplyr::mutate(sce_file_path = file.path(
    integration_input_dir, sample_biomaterial_id, glue::glue("{library_biomaterial_id}_{sce_file_suffix}")
  )) %>%
  dplyr::pull(sce_file_path)
```

To build an initial sense of what we can expect annotating with `SingleR`, let's just look at one SCE (arbitrarily chosen as the first):

```{r}
# For now let's just explore one!
sce_file <- sce_file_paths[[1]]

sce <- readr::read_rds(sce_file)
sce
```


The `celldex` package contains bulk RNA-Seq datasets for use as reference.
Since this is AML data, we'll want a reference that has a lot of blood information.
According to the [`celldex`](https://bioconductor.org/packages/release/data/experiment/vignettes/celldex/inst/doc/userguide.html), the `Human Primary Cell Atlas` data will be our closest match.

> The HPCA reference consists of publicly available microarray datasets derived from human primary cells (Mabbott et al. 2013). Most of the labels refer to blood subpopulations but cell types from other tissues are also available.


```{r}
# define reference with ensembl IDs to match our IDs
ref_se <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE)

# Predict cell types
#  If we change to `labels = ref_se$label.fine`, we'll get more 
#  fine-grained annotations with subtypes etc.
preds_hpca <- SingleR::SingleR(
  # dataset we want to annotate
  test = sce, 
  # reference dataset
  ref = ref_se,
  # label.main is broad 
  labels = ref_se$label.main)


# Results into a tibble:
preds_df <- tibble::as_tibble(preds_hpca$labels) %>%
  dplyr::rename(celltype = value) %>%
  dplyr::mutate(cell_barcode = rownames(preds_hpca),
                reference = "hpca")

# Save the celltypes:
hpca_celltypes <- unique(ref_se$label.main)
```

And a heatmap version, showing all celltypes. 
The bar the top shows the final assignment, which are the rows with highest scores.

```{r, fig.width = 8, fig.height = 5}
SingleR::plotScoreHeatmap(preds_hpca)
```

But can't hurt to see how this compares to the `Blueprint/ENCODE` reference:

> The Blueprint/ENCODE reference consists of bulk RNA-seq data for pure stroma and immune cells generated by Blueprint (Martens and Stunnenberg 2013) and ENCODE projects (The ENCODE Project Consortium 2012).


```{r, fig.width = 8, fig.height = 5}
# define reference with ensembl IDs to match our IDs
ref_se <- celldex::BlueprintEncodeData(ensembl = TRUE)

# Predict cell types, broadly
preds_blue_enc <- SingleR::SingleR(
  # dataset we want to annotate
  test = sce, 
  # reference dataset
  ref = ref_se,
  # label.main is broad 
  labels = ref_se$label.main)


# Results into a tibble:
preds_df <- preds_df %>%
  dplyr::bind_rows(
    tibble::as_tibble(preds_blue_enc$labels) %>%
    dplyr::rename(celltype = value) %>%
    dplyr::mutate(cell_barcode = rownames(preds_blue_enc),
                  reference = "blueprint_encode")
  )

# Save the celltypes:
blueprint_celltypes <- unique(ref_se$label.main)

# And the heatmap:
SingleR::plotScoreHeatmap(preds_blue_enc)
```


What did the references predict?


```{r}
# How many of each celltype?
preds_df %>%
  dplyr::filter(reference == "hpca") %>%
  dplyr::count(celltype) %>%
  dplyr::arrange(-n)


preds_df %>%
  dplyr::filter(reference == "blueprint_encode") %>%
  dplyr::count(celltype) %>%
  dplyr::arrange(-n)
```

We'll have to harmonize the celltype names between references to do a robust comparison, but from a _very_ quick glance, overlap is thinner than one might like.
That said, we don't necessarily expect Blueprint/ENCODE to do particularly well anyways!


For a clearer comparison, we'll harmonize predicted celltypes, but let's just focus on exactly matching celltypes as a start - 
```{r}
# Let's see what we have here:
sort(hpca_celltypes)
sort(blueprint_celltypes)

# Manually compiled data rame of celltypes roughly present in BOTH references
#  for now leaving the Pre/Pro B-cells out
shared_celltypes_df <- tibble::tribble(
  ~hpca_celltype, ~blueprint_celltype,
  # Both references have it:
  "Astrocyte", "Astrocytes",
  "B_cell", "B-cells",
  "Chondrocytes","Chondrocytes",
  "DC", "DC", 
  "Endothelial_cells", "Endothelial cells", 
  "Epithelial_cells", "Epithelial cells", 
  "Fibroblasts", "Fibroblasts", 
  "Keratinocytes", "Keratinocytes", 
  "Macrophage", "Macrophages", 
  "Monocyte", "Monocytes", 
  "Neurons", "Neurons", 
  "Neutrophils", "Neutrophils", 
  "NK_cell", "NK cells", 
  "Smooth_muscle_cells", "Smooth muscle", 
  # two groups - collapse back to overall T cells
  "T_cells", "CD8+ T-cells",
  "T_cells", "CD4+ T-cells",
  # two groups of HSCs, again, collapse back to overall
  "HSC_-G-CSF", "HSC", 
  "HSC_CD34+", "HSC"
) %>%
  dplyr::mutate(harmonized_celltype = ifelse(blueprint_celltype == "HSC",
                                             blueprint_celltype, 
                                             hpca_celltype))

harmonize_celltypes <- function(preds_df, reference_name) {
  if (reference_name == "hpca") {
    shared_celltypes_colname <- rlang::sym("hpca_celltype")
  } else {
    shared_celltypes_colname <- rlang::sym("blueprint_celltype")
  }
  
  filtered_preds_df <- preds_df %>%
    dplyr::filter(reference == reference_name) 
  
  sym_reference_name <- rlang::sym(reference_name)
  filtered_preds_df %>%
    dplyr::inner_join(
      dplyr::select(
        shared_celltypes_df, 
        celltype = {{shared_celltypes_colname}},
        harmonized_celltype
      )
    ) %>% 
    dplyr::select(cell_barcode, {{sym_reference_name}} := harmonized_celltype) %>%
    dplyr::right_join(filtered_preds_df) %>%
    dplyr::mutate({{reference_name}} := dplyr::if_else(
      {{sym_reference_name}} %in% shared_celltypes_df$harmonized_celltype,
      {{sym_reference_name}},
      celltype
    )) %>% 
    dplyr::select(-celltype, -reference)
  }
  
preds_df_harmonized <- harmonize_celltypes(preds_df, "blueprint_encode") %>%
  dplyr::left_join(
    harmonize_celltypes(preds_df, "hpca")  
  )

# How often do they match?

preds_df_harmonized %>%
  dplyr::summarize(percent_same = sum(blueprint_encode == hpca) / dplyr::n() )


# Where do they not match?
preds_df_harmonized %>%
  dplyr::filter(hpca != blueprint_encode)
  
# Are there specific combinations that get differently annotated?
preds_df_harmonized %>%
  dplyr::filter(hpca != blueprint_encode) %>%
  dplyr::select(-cell_barcode) %>%
  dplyr::count(blueprint_encode, hpca) %>%
  dplyr::arrange(-n)

```
## Session Info

```{r session_info}
sessionInfo()
```
