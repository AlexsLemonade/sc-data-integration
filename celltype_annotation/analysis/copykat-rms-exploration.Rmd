---
title: "CopyKAT: Rhabdomyosarcoma cell type tumor vs normal inference for `r {params$library_id}`"
output: 
  html_notebook:
  toc: true
toc_float: true
params:
  s3_singler_data_dir: "s3://nextflow-ccdl-results/scpca/processed/results/SCPCP000005" 
  s3_submitter_data_dir: "s3://sc-data-integration/scpca/celltype_sce"
  local_data_dir: "../data"
  library_id: "SCPCL000488"
  sample_id: "SCPCS000262"
  threads: 16
---
  
This notebook explores performance of the [`copyKat`](https://github.com/navinlabcode/copykat) package for calling tumor vs. normal cells in pediatric cancer scRNA-seq data.
Specifically, we look at a library from the `SCPCP000005` (RMS) project, where the submitter has annotated cell types which we can consider "ground truth" for the purposes of this exploration.
We'll assess agreement between the submitter tumor/normal classification and what `copyKat` infers as tumor/normal, as well as some different `copyKat` parameter values.

## Background: `copyKat` method

Reference: https://doi.org/10.1038/s41587-020-00795-2

To begin, here's a brief overview of the `copyKat` approach, parly quoting the paper throughout.
See Figure 1 in the paper for a method diagram:

* `copyKat` takes the _raw expression matrix_ and stabilizes variance, smooths the outliers
* A subset of cells is then identified to serve as a diploid baseline for subsequent identification of diploid/aneuploid
  * Cells are pooled into clusters with hierarchical clustering, and a GMM estimtes variance of each cluster
  * Cluster with minimal estimated variance is regarded as the "confident diploid cells"
  * **Caution:** This may fail if data has few normal cells and/or there are few CNA events.
  A "GMM definition mode" (sic; I think they meant "model"!) is offered to deal with this (described in paper bottom of pg 599), but implementation details to invoke this mode are thin. I _think_ it is automatically applied?
* MCMC is used to identify chromosome breakpoints with KS tests between gene windows
  * Significant test = probably a breakpoint
  * Final copy numbers for each window are the posterior means of all genes spanning breakpoints
  * These values are converted to genomic positions in 220-kb bins.
  _`copyKat` ultimately provides these values in the outputted CNA matrix._
* Hierarchical clustering identifies largest distance between aneuploid and diploid, but if distance not significant, they switch to the "GMM definition model" to predict tumor cells one-by-one.
* Finally, clustering delinates clonal substructure (not particularly relevant to us) for differential expression.


## Set Up

```{r}
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(ggplot2)
  library(copykat) # https://github.com/navinlabcode/copykat
})

# define output path and SCE file
output_dir <-  here::here("celltype_annotation", 
                          "analysis", 
                          "copykat-results")
fs::dir_create(output_dir)

# Output file that compares results for different distance parameters
copykat_distance_sce <- file.path(output_dir,
                                  glue::glue("{params$library}_copykat_distance_sce.rds"))

# Output file that compares results for different kscut parameters
copykat_kscut_sce <- file.path(output_dir,
                                  glue::glue("{params$library}_copykat_kscut_sce.rds"))
```

In the next chunk, we obtain the _submitter-annotated_ SCE from S3, if it is not already locally present.
We'll wait to read it in when actually running `copyKat`, mostly for memory reasons.


```{r}
# make local data directory if it doesn't exist
if (!dir.exists(params$local_data_dir)) {
  dir.create(params$local_data_dir, recursive = TRUE)
}

# build path to submitter annotated sce file 
submitter_annotated_sce_file <- glue::glue("{params$library_id}_processed_celltype.rds")


local_submitter_sce_path <- file.path(params$local_data_dir,
                                      params$sample_id,
                                      submitter_annotated_sce_file)

# get submitter sce from S3 if not already present locally
if (!(file.exists(local_submitter_sce_path))) {
  sync_call <- glue::glue('op run -- aws s3 sync {params$s3_submitter_data_dir} {params$local_data_dir}/{params$sample_id} --exclude "*" --include "{submitter_annotated_sce_file}"')
  system(sync_call, ignore.stdout = TRUE) 
}
```


## Run CopyKAT across distance parameters

Now, we are ready to run `copyKat` on the SCE, using the _raw expression matrix_ as described in the [GitHub `README` file](https://github.com/navinlabcode/copykat/blob/master/README.md).

Of note, the `README` includes this caveat about the `"distance"` parameter:

> One struggling observation is that none of one clustering method could fit all datasets. In this version, I add a distance parameters for clustering that include "euclidean" distance and correlational distance, ie. 1-"pearson" and "spearman" similarity. In general, corretional distances tend to favor noisy data, while euclidean distance tends to favor data with larger CN segments.

Therefore we'll compare `"euclidian"`, `"spearman"`, and `"pearson"` values for [this parameter](https://github.com/navinlabcode/copykat/blob/b795ff793522499f814f6ae282aad1aab790902f/R/copykat.R#L251-L255).


```{r message=FALSE, warning=FALSE}
# Only run copykat if the final SCE does not exist
if (file.exists(copykat_distance_sce)) {
  
  sce <- readr::read_rds(copykat_distance_sce)
  
} else {
  
  # Otherwise, read in initial SCE and run copyKat
  sce <- readr::read_rds(local_submitter_sce_path)
    
  purrr::walk(
    c("spearman", "pearson", "euclidean"), 
    \(distance_parameter) {
      
      copykat_result <- copykat(
        rawmat = as.matrix(counts(sce)), 
        id.type = "E", # we have Ensembl gene ids, not the default gene symbols ("S")
        sam.name = glue::glue("{params$library_id}-{distance_parameter}"), # unique name for each 
        distance = distance_parameter, 
        plot.genes = FALSE,
        n.cores = params$threads
      )
      
      # save prediction to sce
      colname <- glue::glue("copykat_{distance_parameter}")
      colData(sce)[[colname]] <- copykat_result$prediction$copykat.pred
      
      # export full result
      output_file <- file.path(output_dir,
                              glue::glue("{params$library}_copykat_{distance_parameter}.rds"))
      readr::write_rds(copykat_result, output_file)
    }
  )
  
  # finally, export SCE with all copykat predictions
  readr::write_rds(sce, copykat_distance_sce)
} 
```

## copyKat results: Comparing distance parameters

First, we'll look at quick tables for correspondance between submitter cell type annotations and `copyKat` inferences.
For `copyKat`, "diploid" is normal and "aneuploid" is tumor.

```{r}
table(sce$celltype, sce$copykat_spearman)
```

```{r}
table(sce$celltype, sce$copykat_pearson)
```

```{r}
table(sce$celltype, sce$copykat_euclidian)
```

### Visualization


In this plot, we can see how overall submitter annotations compare to `copyKat` predictions.


```{r}
# Create a data frame that has a `celltype_class` column for a coarser view
#  of submitter cell types. Data will be reused later, so making it here first.
copykat_df <- colData(sce) |>
  as.data.frame() |>
  dplyr::select(celltype, contains("copykat")) |>
  dplyr::mutate(celltype_class = ifelse(
    stringr::str_starts(celltype, "Tumor"), 
    "Tumor", 
    "Normal"
  )) 

# prepare data frame for plotting
copykat_df_long <- copykat_df |>
  tibble::rowid_to_column(var = "cell") |>
  tidyr::drop_na(celltype_class) |>
  tidyr::pivot_longer(
    contains("copykat"), 
    names_to = "copykat_distance", 
    values_to = "prediction"
  ) |>
  dplyr::mutate(copykat_distance = stringr::str_replace(copykat_distance, 
                                                       "copykat_", ""))

# make a barplot of predictions
ggplot(copykat_df_long) + 
  aes(x = celltype_class, fill = prediction) + 
  geom_bar(position = "fill",
           # use alpha to see background grid
           alpha = 0.75) + 
  facet_grid(vars(copykat_distance)) +
  labs(
    x = "Submitter annotation",
    y = "Proportion of cells", 
    fill = "CopyKat prediction"
  ) + 
  # add guideline at y=0.5
  geom_hline(yintercept = 0.5, alpha = 0.25) +
  theme_bw()

```


### Classification metrics 

Next, we'll look at some classification metrics overall, using a custom function to calculate a confusion matrix, 
For the purposes of this analysis, we'll consider submitter-supplied annotations to be "true," and we'll consider "tumor" to be a positive result and "normal" to be a negative result.

For this, we will _only consider_ cells which i) the submitter was able to classify, and ii) `copyKat` was able to classify.
In other words, all `NA` values are removed from the data before calculations.

Briefly, reported metrics can be interpreted as follows:

- Accuracy: Percent of correctly-classified cells.
- True positive rate (tpr): Proportion of true tumor cells correctly identified as being tumor.
- False positive rate (fpr): Proportion of normal cells `copyKat` wrongly thinks are tumor cells.
- False discovery rate (fdr): Proportion of cells that `copyKat` identifies as tumor _that really are tumor cells_.


```{r}
# Custom function to calculate some confusion matrix quantities, including
# accuracy, TPR, and FPR
calculate_confusion <- function(df, copykat_prediction_column) {
  # assumes the true column is `celltype_class`
  df |>
    # remove NA values all around
    tidyr::drop_na(celltype_class) |>
    dplyr::filter({{copykat_prediction_column}} != "not.defined") |>
    # confusion matrix
    dplyr::mutate(confusion = dplyr::case_when(
      celltype_class == "Tumor" & {{copykat_prediction_column}} == "aneuploid"  ~ "TP",
      celltype_class == "Tumor" & {{copykat_prediction_column}} == "diploid"    ~ "FN",
      celltype_class == "Normal" & {{copykat_prediction_column}} == "aneuploid" ~ "FP",
      celltype_class == "Normal" & {{copykat_prediction_column}} == "diploid"   ~ "TN",
      TRUE ~ NA_character_,
    )) |>
    # just in case..
    tidyr::drop_na(confusion) |>
    dplyr::count(confusion) |>
    tidyr::pivot_wider(
      names_from = "confusion", 
      values_from = "n"
    ) |>
    # calculate some metrics
    dplyr::summarize(accuracy = (TP+TN)/(TP+TN+FP+FN), 
                     tpr      = (TP)/(TP+FN),
                     fpr      = (FP)/(FP+TN), 
                     fdr      = (FP)/(FP+TP))
}
```

Now, we'll run the function:

```{r}
# ============== SPEARMAN distance =====================
calculate_confusion(copykat_df, copykat_spearman)

# ============== PEARSON distance =====================
calculate_confusion(copykat_df, copykat_pearson)

# ============== EUCLIDIAN distance =====================
calculate_confusion(copykat_df, copykat_euclidian)
```





## Run CopyKAT across KS.cut parameters

In the above analyses, we saw that correlational distance is likely to be better than euclidian.
In this section, we'll again run `copyKat`, but this time using _only_ the "pearson" distance, at a variety of `KS.cut` parameters.

As described in the [GitHub `README` file](https://github.com/navinlabcode/copykat/blob/master/README.md), 

> KS.cut is the segmentation parameter, ranging from 0 to 1. Increasing KS.cut decreases sensitivity, i.e. less segments/breakpoints. Usually it works in a range of 0.05-0.15.

For this, we'll start with the SCE from the last section, and build it up from there with other `KS.cut` values.
Since it was already run with default `KS.cut = 0.1`, we'll test a few additional values here and compare those to above.

```{r message=FALSE, warning=FALSE}
# Only run copykat if the final SCE does not exist
if (file.exists(copykat_kscut_sce)) {
  
  sce <- readr::read_rds(copykat_kscut_sce)
  
} else {
  
  # Otherwise, run copyKat; no need to read SCE here!
  # but, let's clean it up a bit for this step!
  sce$copykat_spearman <- NULL
  sce$copykat_euclidian <- NULL
  sce$copykat_0.1 <- sce$copykat_pearson # to match columns that get created here

  purrr::walk(
    # skip 0.1!
    c(0.025, 0.05, 0.075, 0.125, 0.15), 
    \(kscut_value) {
      
      copykat_result <- copykat(
        rawmat = as.matrix(counts(sce)), 
        id.type = "E", # we have Ensembl gene ids, not the default gene symbols ("S")
        sam.name = glue::glue("{params$library_id}-{kscut_value}"), # unique name for each 
        distance = "pearson", 
        KS.cut = kscut_value,
        plot.genes = FALSE,
        n.cores = params$threads
      )
      
      # save prediction to sce
      colname <- glue::glue("copykat_{kscut_value}")
      colData(sce)[[colname]] <- copykat_result$prediction$copykat.pred
      
      # export full result
      output_file <- file.path(output_dir,
                              glue::glue("{params$library}_copykat_{kscut_value}.rds"))
      readr::write_rds(copykat_result, output_file)
    }
  )
  
  # finally, export SCE with all copykat predictions
  readr::write_rds(sce, copykat_kscut_sce)
} 
```

## copyKat results: Comparing distance parameters






## Conclusions

`copyKat` does not seem to agree with the submitter annotations, but possibly has the best chance of success with one of the correlational distances (spearman or pearson).

It is also worth noting some drawbacks of the `copyKat` package:

* It emits _a lot of output_, and we don't have much control over it! 
  * This includes both `print()` statements and output files, some of which are optional but not all. 
  * The _lots and lots of output_ is not seen in this notebook because it was rendered after files already existed; the output _cannot_ be suppressed by turning off warnings or messages, because they are all print statements. 
  * Of this output, we get a `"cell: #"` printed for each cell, and we also see that the majority also have a printed statement: `"WARNING! NOT CONVERGENT!"`.
  This latter statement is _printed_ from a [dependency](https://github.com/cran/mixtools/blob/4af1e2789bcea7df3c1775a53cd05b37ec3185d0/R/normalmixEM.R#L129-L131)
* More on the lack of convergence:
  * `copyKat` has hardcoded the maximum number of iterations to 500, but the dependency has this default at 1000. 
  It's possible we'd see convergence with more iterations.
  * This convergence information does _not appear to be captured_ in any of the output - it is just a print statement!
* `copyKat` [hardcodes a random seed](https://github.com/navinlabcode/copykat/blob/b795ff793522499f814f6ae282aad1aab790902f/R/copykat.R#L29-L32) so we can't readily assess bias from starting conditions.

Based on these drawbacks, if we want to use `copyKat` moving forward, we might consider forking the repository and modifying aspects that best suit our needs:
  * More control over the seed
  * Less printing, where possible
  * Fewer output files
  * Increasing the number of iterations (or just removing `copyKat`'s 500 limit and defaulting to the dependency's 1000)
  * If possible, we'd like to _record and export_ which cells do not converge. 
    * Easiest way to get this? Run `copyKat` from a script and capture all the `stdout` into a file we can parse, but that parsing will not necessarily be pleasant!


## Session Info

```{r}
sessionInfo()
```
